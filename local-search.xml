<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>抖音是如何&#39;绑架&#39;我们的</title>
    <link href="/2020/02/13/%E6%8A%96%E9%9F%B3%E6%98%AF%E5%A6%82%E4%BD%95-%E7%BB%91%E6%9E%B6-%E6%88%91%E4%BB%AC%E7%9A%84/"/>
    <url>/2020/02/13/%E6%8A%96%E9%9F%B3%E6%98%AF%E5%A6%82%E4%BD%95-%E7%BB%91%E6%9E%B6-%E6%88%91%E4%BB%AC%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>原文链接： <a href="http://dy.163.com/v2/article/detail/DHEL7NKB0518U04N.html" target="_blank" rel="noopener">http://dy.163.com/v2/article/detail/DHEL7NKB0518U04N.html</a></p><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>这篇文中，抖音只是一个具象化代表，</p><p>​ 我想讲的是以抖音为代表的一众以算法为内核的娱乐化APP。</p><p>　　每个时代都会有一些淘汰机制，</p><p>　　而现在的时代，</p><p>　　会根据自制力和信息筛选能力对人进行淘汰。</p><p>　　但总有一些人是不愿惊醒的，</p><p>　　等他们发现自己一事无成时，</p><p>　　会选择抱怨别人、抱怨社会、然后把希望寄托给下一代，</p><p>　　在这群人眼里错的不是他们，</p><p>　　而是社会。</p><p>　　希望这个人不会是你。</p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>前几天抖音出了一个“爆视频”，单单评论数就超过一百万，播放数量过千万。</p><p>　　这几乎是我们这些文字工作者难以企及的数量。而数量背后，潜藏着一个个为此付出时间与精力的人。<br><img src="/img/content/douyin/1.png" srcset="/img/loading.gif" alt=""></p><p>除此之外，相信你在朋友圈也看到过不少这样的话：</p><p>　　“中了抖音的毒”、“刷抖音根本停不下来啊啊啊，一看表竟然刷了三个多小时……”</p><p><img src="/img/content/douyin/2.png" srcset="/img/loading.gif" alt=""></p><p>这一点相信刷过抖音、亦或者是刷过快手、火山小视频等等各种小视频软件的人都会深有感受。</p><p>　　如果你在路边、休息处看到一个人手指连动笑的合不拢嘴，那大概就是在刷小视频了。</p><p>　　我们会不自觉的深陷其中，蓦然之间发现时间已经过去了几个小时。</p><p>　　尼尔·波兹曼在《娱乐至死》里这样写过这样的一段话：</p><blockquote><p>“一切公众话语日渐以娱乐的方式出现，并成为一种文化精神。我们的政治、宗教、新闻、体育、教育和商业都心甘情愿地成为娱乐的附庸，毫无怨言，甚至无声无息，其结果是我们成了一个娱乐至死的物种。”</p></blockquote><p>层次越低的人，越喜欢花时间在娱乐上。</p><p>　　越来越多的人患上了网络依存症，对各类娱乐新闻上瘾、产生依赖，人云亦云，附和跟风，沉溺在虚拟的世界中不能自拔。</p><p>　　我害怕长久以往，自己会变成一个透明的躯壳，脑袋空空、沉浸于感官娱乐。</p><p>　　有人说，你的时间花在哪，你就会成为什么样的人。格局高的人，不会花太多时间在娱乐上。</p><p>　　深以为然。</p><p>　　我们正在爱上这些使我们丧失思考能力的工业技术。</p><p>　　抖音、快手、抖音、微博这些软件正在飞速地强化我们对新奇事物的需求度，并拉高我们的敏感度。</p><p>　　同时降低的就是对文字的需求度与耐心度。</p><p>　　刷多了抖音、快手、微博这些软件之后，我们就会形成一种惯性：没有耐心去读一本长文或者书籍。更没有时间去思考，因为我们总是在期待着下一个引爆眼球的新奇事物，等待着它在视频中直接了当的呈现。</p><p>　　比如你就有可能看不完我的这篇长文。</p><p>　　而在被轰炸多了之后，我们就会逐渐爱上这种“被喂食”的感觉。</p><p>　　而当“被喂食”形成一种习惯之后，我们的就会惰于思考，耐心以及深挖问题的能力就会被逐渐抹杀。</p><p>　　还记得盛大公司吗？</p><p><img src="/img/content/douyin/3.png" srcset="/img/loading.gif" alt="陈天桥"></p><p>　　这是一家十分“传奇”的公司，2001年年底，盛大账面上只剩下大约30万美金，陈天桥倾囊而出，买下韩国一款二线游戏《传奇》的中国代理权。</p><p>　　2002年，《传奇》同时在线人数突破60万，成为当时世界上最大规模的网络游戏，盛大月均销售额超过千万，市场占有率超过六成。</p><p>　　但是陈天桥在接受记者采访时却不止一次说过：“我从来不玩《传奇》，因为这是个烂游戏，浪费我的时间，但是盛大是个好公司”</p><p>　　但是不可否认的是，这个备受追捧的烂游戏确实吸来了千万销售额。</p><p>　　<strong>看到了么？你每时每刻傻呵呵的沉浸其中，换来的都是经营者的盆满钵满。</strong></p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>“不知道为什么，刷抖音的时候感觉那么开心，可是刷完之后却分外空虚，变得很丧，而且更自卑了”一个粉丝在凌晨一点多私信我。</p><p>　　他说他刚在床上刷完抖音，然后就失眠了。</p><p>　　在孤寂无人的夜晚，我们最容易感受到自己的无助与空虚。</p><p>　　我回复说：“因为你爱上了一个虚拟且充满新奇G点世界，但是你依旧碌碌无为，你的生活仍然平平无奇。”</p><p>　　我称抖音、火山小视频、今日头条、快手等等以算法推荐为内核的软件为：毒品软件。</p><p>　　一款类似抖音的 APP，背后都是一个强大的运营团队，有着专业的消费者行为学作支撑，用尽最前沿的科技，最详尽的数据，通过声、光、交互、反馈等全方位途径，在各种心理学、行为经济学、认知神经科学等理论指导下，精心打造 —— 目的是什么？为了创造一个虚拟空间，来消磨你的时间。</p><p>　　它带来的满足感太容易获得，而一旦你习惯了这种“唾手可得”的满足感，就不愿再去做那些“高投入”的事情了。比如在高度自律的状态下完成作业、思考问题。</p><p>　　在这个被娱乐塞满的世界里，当没有足够强大的自控力时，我们就会因为沉迷各种诱惑而“被碌碌无为”。</p><p>　　比尔盖茨曾在采访中说过，他认为13岁是孩子拥有第一部手机的合适年龄。</p><p><img src="/img/content/douyin/4.png" srcset="/img/loading.gif" alt="比尔盖茨和女儿"></p><p>　　他、珍妮弗、以及1999年出生的儿子罗里·盖茨都是在过了13岁生日后才被允许使用手机，小女儿菲比则在期待着13岁生日时得到自己的第一部手机。</p><p>　　“我们家把13岁定为得到手机的年限。”盖茨说，鉴于这项规定，孩子们从学校回家后常向他抱怨说，“其他孩子都有手机，我是唯一一个没有手机的人，这令人尴尬”。</p><p>　　<strong>你知道吗？乔布斯是不允许自己的孩子们用iPad的。</strong></p><p><img src="/img/content/douyin/5.png" srcset="/img/loading.gif" alt=""></p><p>乔布斯生前有三个年幼的孩子。有一天纽约时报的记者Nick Bilto问他：</p><blockquote><p>“你的孩子们一定很喜欢iPad吧？”</p></blockquote><p>老乔回答：</p><blockquote><p>“他们没有用过。我们限制孩子们在家里使用智能产品。”</p></blockquote><p>　　听起来是不是怪怪的？iPad之父居然不允许自己的孩子用iPad?感觉就像是毒贩不允许自己的孩子吸毒一样….</p><p>　　无独有偶。<strong>在硅谷，很多高科技公司的高层和工程师里面，开始流行不让自己的孩子接触智能科技产品。</strong></p><p>　　他们甚至把孩子们送到传统的，完全没有智能和科技产品的Waldorf学校，在这个学校的校园里根本就找不到电脑！</p><p>　　我们看到的是电子产品正在飞速低龄化，抖音快手已经迅速占据了小学生的生活。</p><p><img src="/img/content/douyin/6.png" srcset="/img/loading.gif" alt=""></p><p>而因为缺乏自制力，他们会沉浸其中无法自拔，在最应当拼搏的年纪里选择安逸，在价值观形成之际被灌输进大量的光怪陆离与不正之风。</p><p>　　于是他们开始模仿，追逐着未成年怀孕风当宝妈、跟着小青年跳社会摇、以为低胸博眼球就能赚大钱……当管制不利时，堕落便自此开始。</p><p>　　那些我们所热爱的东西，正在一步步把我们连根拔起。</p><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>在作家周冲的文章中看到过这样一段话：</p><blockquote><p>当你的时间不再用于深度学习，当你的注意力被他人瓜分，当你只看综艺与电视剧，当你在群体中呆的时间越来越长，当你执行力越来越差，当你评价他人的次数越来越多，当你抱怨越来越频繁，当你回想往事的频率越来越高……毁灭就已经发生了。</p></blockquote><p>　　如何分配你的时间，取决于你。</p><p>　　罗振宇说，未来，在时间这个战场上，有两门生意会特别值钱。</p><p>　　第一，就是帮别人省时间。第二，就是帮别人把省下来的时间浪费在那些美好的事物上。</p><p>　　能够掌控时间的人，才能掌控自己的一生。</p><p>　　这座城市，一半人在拼命，一半人在认命；一半人在抢时间，一半人在耗时间；一半人在燃烧青春，一半人在虚度青春。</p><p>　　你愿意做哪一半的人？</p>]]></content>
    
    
    
    <tags>
      
      <tag>推文</tag>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据分析入门</title>
    <link href="/2020/02/13/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/"/>
    <url>/2020/02/13/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="更新中…"><a href="#更新中…" class="headerlink" title="更新中…"></a>更新中…</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Matplotlib介绍与使用</title>
    <link href="/2020/02/13/Matplotlib%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/02/13/Matplotlib%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>参考链接：</p><blockquote><p><a href="https://matplotlib.org/" target="_blank" rel="noopener">https://matplotlib.org/</a><br><a href="https://blog.csdn.net/luanpeng825485697/article/details/78508819" target="_blank" rel="noopener">https://blog.csdn.net/luanpeng825485697/article/details/78508819</a></p></blockquote><p>matplotlib是受MATLAB的启发构建的。MATLAB是数据绘图领域广泛使用的语言和工具。MATLAB语言是面向过程的。利用函数的调用，MATLAB中可以轻松的利用一行命令来绘制直线，然后再用一系列的函数调整结果。</p><p>matplotlib有一套完全仿照MATLAB的函数形式的绘图接口，在matplotlib.pyplot模块中。这套函数接口方便MATLAB用户过度到matplotlib包</p><p>学习方式：从官网examples入门学习</p><p><a href="http://matplotlib.org/examples/index.html" target="_blank" rel="noopener">http://matplotlib.org/examples/index.html</a><br><a href="http://matplotlib.org/gallery.html" target="_blank" rel="noopener">http://matplotlib.org/gallery.html</a></p><pre><code class="python"> import matplotlib.pyplot as plt</code></pre><blockquote><p>在绘图结构中，figure创建窗口，subplot创建子图。所有的绘画只能在子图上进行。plt表示当前子图，若没有就创建一个子图。所有你会看到一些教程中使用plt进行设置，一些教程使用子图属性进行设置。他们往往存在对应功能函数。</p></blockquote><p>Figure：面板(图)，matplotlib中的所有图像都是位于figure对象中，一个图像只能有一个figure对象。</p><p>Subplot：子图，figure对象下创建一个或多个subplot对象(即axes)用于绘制图像。</p><p><img src="/img/content/matplotlib/1.png" srcset="/img/loading.gif" alt=""></p><h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数:"></a>配置参数:</h2><ul><li>axex: 设置坐标轴边界和表面的颜色、坐标刻度值大小和网格的显示</li><li>figure: 控制dpi、边界颜色、图形大小、和子区( subplot)设置</li><li>font: 字体集（font family）、字体大小和样式设置</li><li>grid: 设置网格颜色和线性</li><li>legend: 设置图例和其中的文本的显示</li><li>line: 设置线条（颜色、线型、宽度等）和标记</li><li>patch: 是填充2D空间的图形对象，如多边形和圆。控制线宽、颜色和抗锯齿设置等。</li><li>savefig: 可以对保存的图形进行单独设置。例如，设置渲染的文件的背景为白色。</li><li>verbose: 设置matplotlib在执行期间信息输出，如silent、helpful、debug和debug-annoying。</li><li>xticks和yticks: 为x,y轴的主刻度和次刻度设置颜色、大小、方向，以及标签大小。</li></ul><h2 id="线条相关属性标记设置"><a href="#线条相关属性标记设置" class="headerlink" title="线条相关属性标记设置"></a>线条相关属性标记设置</h2><table><thead><tr><th align="left">线条风格linestyle或ls</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">‘-‘</td><td align="left">实线</td></tr><tr><td align="left">‘:’</td><td align="left">虚线</td></tr><tr><td align="left">‘–’</td><td align="left">破折线</td></tr><tr><td align="left">‘None’,’ ‘,’’</td><td align="left">什么都不画</td></tr><tr><td align="left">‘-.’</td><td align="left">点划线</td></tr></tbody></table><h2 id="线条标记"><a href="#线条标记" class="headerlink" title="线条标记"></a>线条标记</h2><pre><code>标记maker            描述‘o’                 圆圈  ‘.’                 点‘D’                 菱形  ‘s’                 正方形‘h’                 六边形1    ‘*’                 星号‘H’                 六边形2    ‘d’                 小菱形‘_’                 水平线 ‘v’                 一角朝下的三角形‘8’                 八边形 ‘&lt;’                 一角朝左的三角形‘p’                 五边形 ‘&gt;’                 一角朝右的三角形‘,’                 像素  ‘^’                 一角朝上的三角形‘+’                 加号  ‘\  ‘               竖线‘None’,’’,’ ‘       无   ‘x’                 X</code></pre><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><pre><code>别名             颜色   b               蓝色  g               绿色r               红色  y               黄色c               青色k               黑色   m               洋红色 w               白色</code></pre><p>如果这两种颜色不够用，还可以通过两种其他方式来定义颜色值：</p><p>1、使用HTML十六进制字符串 color=’#123456’ 使用合法的HTML颜色名字（’red’,’chartreuse’等）。<br>2、也可以传入一个归一化到[0,1]的RGB元祖。 color=(0.3,0.3,0.4)</p><h2 id="背景色"><a href="#背景色" class="headerlink" title="背景色"></a>背景色</h2><p>通过向如matplotlib.pyplot.axes()或者matplotlib.pyplot.subplot()这样的方法提供一个axisbg参数，可以指定坐标这的背景色。</p><p>subplot(111,axisbg=(0.1843,0.3098,0.3098)）</p><p>以下示例需要引入的库包括</p><pre><code class="python">import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom matplotlib.ticker import MultipleLocator</code></pre><h2 id="绘图操作步骤（以点图、线图为例）"><a href="#绘图操作步骤（以点图、线图为例）" class="headerlink" title="绘图操作步骤（以点图、线图为例）"></a>绘图操作步骤（以点图、线图为例）</h2><pre><code class="python">#使用numpy产生数据x=np.arange(-5,5,0.1)y=x*3#创建窗口、子图#方法1：先创建窗口，再创建子图。（一定绘制）fig = plt.figure(num=1, figsize=(15, 8),dpi=80)     #开启一个窗口，同时设置大小，分辨率ax1 = fig.add_subplot(2,1,1)  #通过fig添加子图，参数：行数，列数，第几个。ax2 = fig.add_subplot(2,1,2)  #通过fig添加子图，参数：行数，列数，第几个。print(fig,ax1,ax2)#方法2：一次性创建窗口和多个子图。（空白不绘制）fig,axarr = plt.subplots(4,1)  #开一个新窗口，并添加4个子图，返回子图数组ax1 = axarr[0]    #通过子图数组获取一个子图print(fig,ax1)#方法3：一次性创建窗口和一个子图。（空白不绘制）ax1 = plt.subplot(1,1,1,facecolor=&#39;white&#39;)      #开一个新窗口，创建1个子图。facecolor设置背景颜色print(ax1)#获取对窗口的引用，适用于上面三种方法# fig = plt.gcf()   #获得当前figure# fig=ax1.figure   #获得指定子图所属窗口# fig.subplots_adjust(left=0)                         #设置窗口左内边距为0，即左边留白为0。#设置子图的基本元素ax1.set_title(&#39;python-drawing&#39;)            #设置图体，plt.titleax1.set_xlabel(&#39;x-name&#39;)                    #设置x轴名称,plt.xlabelax1.set_ylabel(&#39;y-name&#39;)                    #设置y轴名称,plt.ylabelplt.axis([-6,6,-10,10])                  #设置横纵坐标轴范围，这个在子图中被分解为下面两个函数ax1.set_xlim(-5,5)                           #设置横轴范围，会覆盖上面的横坐标,plt.xlimax1.set_ylim(-10,10)                         #设置纵轴范围，会覆盖上面的纵坐标,plt.ylimxmajorLocator = MultipleLocator(2)   #定义横向主刻度标签的刻度差为2的倍数。就是隔几个刻度才显示一个标签文本ymajorLocator = MultipleLocator(3)   #定义纵向主刻度标签的刻度差为3的倍数。就是隔几个刻度才显示一个标签文本ax1.xaxis.set_major_locator(xmajorLocator) #x轴 应用定义的横向主刻度格式。如果不应用将采用默认刻度格式ax1.yaxis.set_major_locator(ymajorLocator) #y轴 应用定义的纵向主刻度格式。如果不应用将采用默认刻度格式ax1.xaxis.grid(True, which=&#39;major&#39;)      #x坐标轴的网格使用定义的主刻度格式ax1.yaxis.grid(True, which=&#39;major&#39;)      #x坐标轴的网格使用定义的主刻度格式ax1.set_xticks([])     #去除坐标轴刻度ax1.set_xticks((-5,-3,-1,1,3,5))  #设置坐标轴刻度ax1.set_xticklabels(labels=[&#39;x1&#39;,&#39;x2&#39;,&#39;x3&#39;,&#39;x4&#39;,&#39;x5&#39;],rotation=-30,fontsize=&#39;small&#39;)  #设置刻度的显示文本，rotation旋转角度，fontsize字体大小plot1=ax1.plot(x,y,marker=&#39;o&#39;,color=&#39;g&#39;,label=&#39;legend1&#39;)   #点图：marker图标plot2=ax1.plot(x,y,linestyle=&#39;--&#39;,alpha=0.5,color=&#39;r&#39;,label=&#39;legend2&#39;)   #线图：linestyle线性，alpha透明度，color颜色，label图例文本ax1.legend(loc=&#39;upper left&#39;)            #显示图例,plt.legend()ax1.text(2.8, 7, r&#39;y=3*x&#39;)                #指定位置显示文字,plt.text()ax1.annotate(&#39;important point&#39;, xy=(2, 6), xytext=(3, 1.5),  #添加标注，参数：注释文本、指向点、文字位置、箭头属性            arrowprops=dict(facecolor=&#39;black&#39;, shrink=0.05),            )#显示网格。which参数的值为major(只绘制大刻度)、minor(只绘制小刻度)、both，默认值为major。axis为&#39;x&#39;,&#39;y&#39;,&#39;both&#39;ax1.grid(b=True,which=&#39;major&#39;,axis=&#39;both&#39;,alpha= 0.5,color=&#39;skyblue&#39;,linestyle=&#39;--&#39;,linewidth=2)axes1 = plt.axes([.2, .3, .1, .1], facecolor=&#39;y&#39;)       #在当前窗口添加一个子图，rect=[左, 下, 宽, 高]，是使用的绝对布局，不和以存在窗口挤占空间axes1.plot(x,y)  #在子图上画图plt.savefig(&#39;aa.jpg&#39;,dpi=400,bbox_inches=&#39;tight&#39;)   #savefig保存图片，dpi分辨率，bbox_inches子图周边白色空间的大小plt.show()    #打开窗口，对于方法1创建在窗口一定绘制，对于方法2方法3创建的窗口，若坐标系全部空白，则不绘制</code></pre><p><img src="/img/content/matplotlib/2.png" srcset="/img/loading.gif" alt=""></p><p><strong>plot时可以设置的属性包括如下：</strong></p><pre><code>属性                      值类型alpha                   浮点值animated                [True / False]antialiased or aa       [True / False]clip_box                matplotlib.transform.Bbox 实例clip_on                 [True / False]clip_path               Path 实例， Transform，以及Patch实例color or c              任何 matplotlib 颜色contains                命中测试函数dash_capstyle           [&#39;butt&#39; / &#39;round&#39; / &#39;projecting&#39;]dash_joinstyle          [&#39;miter&#39; / &#39;round&#39; / &#39;bevel&#39;]dashes                  以点为单位的连接/断开墨水序列data                    (np.array xdata, np.array ydata)figure                  matplotlib.figure.Figure 实例label                   任何字符串linestyle or ls         [ &#39;-&#39; / &#39;--&#39; / &#39;-.&#39; / &#39;:&#39; / &#39;steps&#39; / ...]linewidth or lw         以点为单位的浮点值lod                     [True / False]marker                  [ &#39;+&#39; / &#39;,&#39; / &#39;.&#39; / &#39;1&#39; / &#39;2&#39; / &#39;3&#39; / &#39;4&#39; ]markeredgecolor or mec  任何 matplotlib 颜色markeredgewidth or mew  以点为单位的浮点值markerfacecolor or mfc  任何 matplotlib 颜色markersize or ms        浮点值markevery               [ None / 整数值 / (startind, stride) ]picker                  用于交互式线条选择pickradius              线条的拾取选择半径solid_capstyle          [&#39;butt&#39; / &#39;round&#39; / &#39;projecting&#39;]solid_joinstyle         [&#39;miter&#39; / &#39;round&#39; / &#39;bevel&#39;]transform               matplotlib.transforms.Transform 实例visible                 [True / False]xdata                   np.arrayydata                   np.arrayzorder                  任何数值</code></pre><p><strong>一个窗口多个图</strong></p><pre><code>#一个窗口，多个图，多条数据sub1=plt.subplot(211,facecolor=(0.1843,0.3098,0.3098))  #将窗口分成2行1列，在第1个作图，并设置背景色sub2=plt.subplot(212)   #将窗口分成2行1列，在第2个作图sub1.plot(x,y)          #绘制子图sub2.plot(x,y)          #绘制子图axes1 = plt.axes([.2, .3, .1, .1], facecolor=&#39;y&#39;)  #添加一个子坐标系，rect=[左, 下, 宽, 高]plt.plot(x,y)           #绘制子坐标系，axes2 = plt.axes([0.7, .2, .1, .1], facecolor=&#39;y&#39;)  #添加一个子坐标系，rect=[左, 下, 宽, 高]plt.plot(x,y)plt.show()</code></pre><p><img src="/img/content/matplotlib/3.png" srcset="/img/loading.gif" alt=""></p><h2 id="极坐标"><a href="#极坐标" class="headerlink" title="极坐标"></a>极坐标</h2><p>属性设置同点图、线图中。</p><pre><code>fig = plt.figure(2)                                #新开一个窗口ax1 = fig.add_subplot(1,2,1,polar=True)                  #启动一个极坐标子图theta=np.arange(0,2*np.pi,0.02)              #角度数列值ax1.plot(theta,2*np.ones_like(theta),lw=2)   #画图，参数：角度，半径，lw线宽ax1.plot(theta,theta/6,linestyle=&#39;--&#39;,lw=2)           #画图，参数：角度，半径，linestyle样式，lw线宽ax2 = fig.add_subplot(1,2,2,polar=True)                  #启动一个极坐标子图ax2.plot(theta,np.cos(5*theta),linestyle=&#39;--&#39;,lw=2)ax2.plot(theta,2*np.cos(4*theta),lw=2)ax2.set_rgrids(np.arange(0.2,2,0.2),angle=45)   #距离网格轴，轴线刻度和显示位置ax2.set_thetagrids([0,45,90])                   #角度网格轴，范围0-360度plt.show()</code></pre><p><img src="/img/content/matplotlib/4.png" srcset="/img/loading.gif" alt=""></p><h2 id="柱形图"><a href="#柱形图" class="headerlink" title="柱形图"></a>柱形图</h2><p>属性设置同点图、线图中。</p><pre><code>plt.figure(3)x_index = np.arange(5)   #柱的索引x_data = (&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;)y1_data = (20, 35, 30, 35, 27)y2_data = (25, 32, 34, 20, 25)bar_width = 0.35   #定义一个数字代表每个独立柱的宽度rects1 = plt.bar(x_index, y1_data, width=bar_width,alpha=0.4, color=&#39;b&#39;,label=&#39;legend1&#39;)            #参数：左偏移、高度、柱宽、透明度、颜色、图例rects2 = plt.bar(x_index + bar_width, y2_data, width=bar_width,alpha=0.5,color=&#39;r&#39;,label=&#39;legend2&#39;) #参数：左偏移、高度、柱宽、透明度、颜色、图例#关于左偏移，不用关心每根柱的中心不中心，因为只要把刻度线设置在柱的中间就可以了plt.xticks(x_index + bar_width/2, x_data)   #x轴刻度线plt.legend()    #显示图例plt.tight_layout()  #自动控制图像外部边缘，此方法不能够很好的控制图像间的间隔plt.show()</code></pre><p><img src="/img/content/matplotlib/5.png" srcset="/img/loading.gif" alt=""></p><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><pre><code>fig,(ax0,ax1) = plt.subplots(nrows=2,figsize=(9,6))     #在窗口上添加2个子图sigma = 1   #标准差mean = 0    #均值x=mean+sigma*np.random.randn(10000)   #正态分布随机数ax0.hist(x,bins=40,normed=False,histtype=&#39;bar&#39;,facecolor=&#39;yellowgreen&#39;,alpha=0.75)   #normed是否归一化，histtype直方图类型，facecolor颜色，alpha透明度ax1.hist(x,bins=20,normed=1,histtype=&#39;bar&#39;,facecolor=&#39;pink&#39;,alpha=0.75,cumulative=True,rwidth=0.8) #bins柱子的个数,cumulative是否计算累加分布，rwidth柱子宽度plt.show()  #所有窗口运行</code></pre><p><img src="/img/content/matplotlib/6.png" srcset="/img/loading.gif" alt=""></p><h2 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h2><pre><code>fig = plt.figure(4)          #添加一个窗口ax =fig.add_subplot(1,1,1)   #在窗口上添加一个子图x=np.random.random(100)      #产生随机数组y=np.random.random(100)      #产生随机数组ax.scatter(x,y,s=x*1000,c=&#39;y&#39;,marker=(5,1),alpha=0.5,lw=2,facecolors=&#39;none&#39;)  #x横坐标，y纵坐标，s图像大小，c颜色，marker图片，lw图像边框宽度plt.show()  #所有窗口运行</code></pre><p><img src="/img/content/matplotlib/7.png" srcset="/img/loading.gif" alt=""></p><h2 id="三维图"><a href="#三维图" class="headerlink" title="三维图"></a>三维图</h2><pre><code>fig = plt.figure(5)ax=fig.add_subplot(1,1,1,projection=&#39;3d&#39;)     #绘制三维图x,y=np.mgrid[-2:2:20j,-2:2:20j]  #获取x轴数据，y轴数据z=x*np.exp(-x**2-y**2)   #获取z轴数据ax.plot_surface(x,y,z,rstride=2,cstride=1,cmap=plt.cm.coolwarm,alpha=0.8)  #绘制三维图表面ax.set_xlabel(&#39;x-name&#39;)     #x轴名称ax.set_ylabel(&#39;y-name&#39;)     #y轴名称ax.set_zlabel(&#39;z-name&#39;)     #z轴名称plt.show()</code></pre><h2 id="画矩形、多边形、圆形和椭圆"><a href="#画矩形、多边形、圆形和椭圆" class="headerlink" title="画矩形、多边形、圆形和椭圆"></a>画矩形、多边形、圆形和椭圆</h2><pre><code>fig = plt.figure(6)   #创建一个窗口ax=fig.add_subplot(1,1,1)   #添加一个子图rect1 = plt.Rectangle((0.1,0.2),0.2,0.3,color=&#39;r&#39;)  #创建一个矩形，参数：(x,y),width,heightcirc1 = plt.Circle((0.7,0.2),0.15,color=&#39;r&#39;,alpha=0.3)  #创建一个椭圆，参数：中心点，半径，默认这个圆形会跟随窗口大小进行长宽压缩pgon1 = plt.Polygon([[0.45,0.45],[0.65,0.6],[0.2,0.6]])  #创建一个多边形，参数：每个顶点坐标ax.add_patch(rect1)  #将形状添加到子图上ax.add_patch(circ1)  #将形状添加到子图上ax.add_patch(pgon1)  #将形状添加到子图上fig.canvas.draw()  #子图绘制plt.show()</code></pre><p><img src="/img/content/matplotlib/8.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Numpy使用</title>
    <link href="/2020/02/13/Numpy%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/02/13/Numpy%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>参考链接：</p><blockquote><p><a href="https://numpy.org/" target="_blank" rel="noopener">https://numpy.org/</a><br><a href="https://blog.csdn.net/cxmscb/article/details/54583415" target="_blank" rel="noopener">https://blog.csdn.net/cxmscb/article/details/54583415</a></p></blockquote><h2 id="NumPy数组对象"><a href="#NumPy数组对象" class="headerlink" title="NumPy数组对象"></a>NumPy数组对象</h2><ul><li><p>NumPy中的ndarray是一个多维数组对象，该对象由两部分组成</p><ul><li>实际的数据</li><li>描述这些数据的元数据</li></ul></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(15).reshape(3, 5)&gt;&gt;&gt; aarray([[ 0,  1,  2,  3,  4],       [ 5,  6,  7,  8,  9],       [10, 11, 12, 13, 14]])&gt;&gt;&gt; a.shape(3, 5)&gt;&gt;&gt; a.ndim  # 数组轴的个数，在python的世界中，轴的个数被称作秩2&gt;&gt;&gt; a.dtype.name&#39;int64&#39;&gt;&gt;&gt; a.itemsize  # 数组中每个元素的字节大小。8&gt;&gt;&gt; a.size15&gt;&gt;&gt; type(a)&lt;type &#39;numpy.ndarray&#39;&gt;&gt;&gt;&gt; b = np.array([6, 7, 8])&gt;&gt;&gt; barray([6, 7, 8])&gt;&gt;&gt; type(b)&lt;type &#39;numpy.ndarray&#39;&gt;</code></pre><h2 id="创建矩阵"><a href="#创建矩阵" class="headerlink" title="创建矩阵"></a>创建矩阵</h2><p>对于Python中的numpy模块，一般用其提供的ndarray对象。 创建一个ndarray对象很简单，只要将一个list作为参数即可。 例如:</p><pre><code class="python">&gt;&gt;&gt; import numpy as np#创建一维的narray对象&gt;&gt;&gt; a = np.array([2,3,4])&gt;&gt;&gt; aarray([2, 3, 4])&gt;&gt;&gt; a.dtypedtype(&#39;int64&#39;)# 浮点类型&gt;&gt;&gt; b = np.array([1.2, 3.5, 5.1])&gt;&gt;&gt; b.dtypedtype(&#39;float64&#39;)#创建二维的narray对象&gt;&gt;&gt;a2 = np.array([[1,2,3,4,5],[6,7,8,9,10]])&gt;&gt;&gt; b = np.array([(1.5,2,3), (4,5,6)])  # 使用的是元组&gt;&gt;&gt; barray([[ 1.5,  2. ,  3. ],       [ 4. ,  5. ,  6. ]])# The type of the array can also be explicitly specified at creation time:&gt;&gt;&gt; c = np.array( [ [1,2], [3,4] ], dtype=complex )&gt;&gt;&gt; carray([[ 1.+0.j,  2.+0.j],       [ 3.+0.j,  4.+0.j]])</code></pre><h2 id="矩阵行数列数"><a href="#矩阵行数列数" class="headerlink" title="矩阵行数列数"></a>矩阵行数列数</h2><pre><code class="python">import numpy as npa = np.array([[1,2,3,4,5],[6,7,8,9,10]])print(a.shape) #结果返回一个tuple元组 (2, 5) 2行，5列print(a.shape[0]) #获得行数，返回 2print(a.shape[1]) #获得列数，返回 5</code></pre><h2 id="矩阵按行列选取"><a href="#矩阵按行列选取" class="headerlink" title="矩阵按行列选取"></a>矩阵按行列选取</h2><p>矩阵的截取和list相同，可以通过[]（方括号）来截取</p><pre><code class="python">import numpy as npa = np.array([[1,2,3,4,5],[6,7,8,9,10]])print(a[0:1]) #截取第一行,返回 [[1 2 3 4 5]]print(a[1,2:5]) #截取第二行，第三、四、五列，返回 [8 9 10]print(a[1,:]) #截取第二行,返回 [ 6  7  8  9 10]</code></pre><h2 id="矩阵按条件截取"><a href="#矩阵按条件截取" class="headerlink" title="矩阵按条件截取"></a>矩阵按条件截取</h2><pre><code class="python">import numpy as npa = np.array([[1,2,3,4,5],[6,7,8,9,10]])b = a[a&gt;6] # 截取矩阵a中大于6的元素，返回的是一维数组print(b) # 返回 [ 7  8  9 10]# 其实布尔语句首先生成一个布尔矩阵，将布尔矩阵传入[]（方括号）实现截取print(a&gt;6) # 返回[[False False False False False] [False  True  True  True  True]]</code></pre><p>按条件截取应用较多的是对矩阵中满足一定条件的元素变成特定的值。 例如将矩阵中大于6的元素变成0。</p><pre><code class="python">import numpy as npa = np.array([[1,2,3,4,5],[6,7,8,9,10]])print(a)#开始矩阵为[[ 1  2  3  4  5] [ 6  7  8  9 10]]a[a&gt;6] = 0print(a)#大于6清零后矩阵为[[1 2 3 4 5] [6 0 0 0 0]]</code></pre><h2 id="Stacking-together-different-arrays"><a href="#Stacking-together-different-arrays" class="headerlink" title="Stacking together different arrays"></a>Stacking together different arrays</h2><p>矩阵的合并可以通过numpy中的hstack方法和vstack方法实现:</p><pre><code class="python">&gt;&gt;&gt; a = np.floor(10*np.random.random((2,2)))&gt;&gt;&gt; aarray([[ 8.,  8.],       [ 0.,  0.]])&gt;&gt;&gt; b = np.floor(10*np.random.random((2,2)))&gt;&gt;&gt; barray([[ 1.,  8.],       [ 0.,  4.]])&gt;&gt;&gt; np.vstack((a,b))array([[ 8.,  8.],       [ 0.,  0.],       [ 1.,  8.],       [ 0.,  4.]])&gt;&gt;&gt; np.hstack((a,b))array([[ 8.,  8.,  1.,  8.],       [ 0.,  0.,  0.,  4.]])</code></pre><ul><li>矩阵的合并也可以通过concatenatef方法。</li><li>np.concatenate( (a1,a2), axis=0 ) 等价于 np.vstack( (a1,a2) )</li><li>np.concatenate( (a1,a2), axis=1 ) 等价于 np.hstack( (a1,a2) )</li></ul><h2 id="通过函数创建矩阵"><a href="#通过函数创建矩阵" class="headerlink" title="通过函数创建矩阵"></a>通过函数创建矩阵</h2><p><strong>arange</strong></p><pre><code class="python">import numpy as npa = np.arange(10) # 默认从0开始到10（不包括10），步长为1print(a) # 返回 [0 1 2 3 4 5 6 7 8 9]a1 = np.arange(5,10) # 从5开始到10（不包括10），步长为1print(a1) # 返回 [5 6 7 8 9]a2 = np.arange(5,20,2) # 从5开始到20（不包括20），步长为2print(a2) # 返回 [ 5  7  9 11 13 15 17 19]</code></pre><p><strong>linspace/ logspace</strong></p><pre><code class="python">import numpy as np# 类似于matlaba = np.linspace(0,10,7) # 生成首位是0，末位是10，含7个数的等差数列print(a) # 结果 [  0.           1.66666667   3.33333333   5.         6.66666667  8.33333333  10.    ]&gt;&gt;&gt; a = np.ones(3, dtype=np.int32)&gt;&gt;&gt; b = np.linspace(0,pi,3)&gt;&gt;&gt; b.dtype.name&#39;float64&#39;&gt;&gt;&gt; c = a+b&gt;&gt;&gt; carray([ 1.        ,  2.57079633,  4.14159265])&gt;&gt;&gt; c.dtype.name&#39;float64&#39;&gt;&gt;&gt; d = np.exp(c*1j)&gt;&gt;&gt; darray([ 0.54030231+0.84147098j, -0.84147098+0.54030231j,       -0.54030231-0.84147098j])&gt;&gt;&gt; d.dtype.name&#39;complex128&#39;</code></pre><p><strong>ones、zeros、eye、empty</strong><br>ones创建全1矩阵 ，zeros创建全0矩阵 ，eye创建单位矩阵 ，empty创建空矩阵（实际有值）</p><pre><code class="python">import numpy as npa_ones = np.ones((3,4)) # 创建3*4的全1矩阵print(a_ones)# 结果[[ 1.  1.  1.  1.] [ 1.  1.  1.  1.] [ 1.  1.  1.  1.]]&gt;&gt;&gt; np.ones((2,3,4), dtype=np.int16 )   # dtype can also be specifiedarray([[[ 1, 1, 1, 1],        [ 1, 1, 1, 1],        [ 1, 1, 1, 1]],       [[ 1, 1, 1, 1],        [ 1, 1, 1, 1],        [ 1, 1, 1, 1]]], dtype=int16)a_zeros = np.zeros((3,4)) # 创建3*4的全0矩阵print(a_zeros)# 结果[[ 0.  0.  0.  0.] [ 0.  0.  0.  0.] [ 0.  0.  0.  0.]]a_eye = np.eye(3) # 创建3阶单位矩阵print(a_eye)# 结果[[ 1.  0.  0.] [ 0.  1.  0.] [ 0.  0.  1.]]a_empty = np.empty((3,4)) # 创建3*4的空矩阵 print(a_empty)# 结果[[  1.78006111e-306  -3.13259416e-294   4.71524461e-309   1.94927842e+289] [  2.10230387e-309   5.42870216e+294   6.73606381e-310   3.82265219e-297] [  6.24242356e-309   1.07034394e-296   2.12687797e+183   6.88703165e-315]]# 有些矩阵太大，如果不想省略中间部分，通过set_printoptions来强制NumPy打印所有数据。&gt;&gt;&gt; np.set_printoptions(threshold=&#39;nan&#39;)</code></pre><p><strong>fromstring</strong><br>fromstring()方法可以将字符串转化成ndarray对象，需要将字符串数字化时这个方法比较有用，可以获得字符串的ascii码序列。</p><pre><code class="python">import numpy as npa = &quot;abcdef&quot;b = np.fromstring(a,dtype=np.int8) # 因为一个字符为8位，所以指定dtype为np.int8print(b) # 返回 [ 97  98  99 100 101 102] </code></pre><p><strong>random</strong></p><pre><code class="python">&gt;&gt;&gt; a = np.random.random((2,3)) # 产生2行,3列的随机矩阵 &gt;&gt;&gt; aarray([[ 0.18626021,  0.34556073,  0.39676747],       [ 0.53881673,  0.41919451,  0.6852195 ]])</code></pre><p><strong>fromfunction</strong><br>fromfunction()方法可以根据矩阵的行号列号生成矩阵的元素。 例如创建一个矩阵，矩阵中的每个元素都为行号和列号的和。</p><pre><code class="python">import numpy as npdef func(i,j):     return i+ja = np.fromfunction(func,(5,6)) # 第一个参数为指定函数，第二个参数为列表list或元组tuple,说明矩阵的大小print(a)# 返回[[ 0.  1.  2.  3.  4.  5.] [ 1.  2.  3.  4.  5.  6.] [ 2.  3.  4.  5.  6.  7.] [ 3.  4.  5.  6.  7.  8.] [ 4.  5.  6.  7.  8.  9.]]#注意这里行号的列号都是从0开始的</code></pre><h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><p><strong>常用矩阵运算符</strong><br>Numpy中的ndarray对象重载了许多运算符，使用这些运算符可以完成矩阵间对应元素的运算。</p><p>运算符说明+矩阵对应元素相加-矩阵对应元素相减*矩阵对应元素相乘/矩阵对应元素相除，如果都是整数则取商%矩阵对应元素相除后取余数**矩阵每个元素都取n次方，如**2：每个元素都取平方</p><pre><code class="python">import numpy as npa1 = np.array([[4,5,6],[1,2,3]])a2 = np.array([[6,5,4],[3,2,1]])print(a1+a2) # 相加# 结果[[10 10 10] [ 4  4  4]]print(a1/a2) # 整数相除取商# 结果[[0 1 1] [0 1 3]]print(a1%a2) # 相除取余数# 结果[[4 0 2] [1 0 0]]</code></pre><p><strong>常用矩阵函数</strong></p><p>同样地，numpy中也定义了许多函数，使用这些函数可以将函数作用于矩阵中的每个元素。 表格中默认导入了numpy模块，即 import numpy as np 。a为ndarray对象。</p><p><strong>常用矩阵函数说明</strong>np.sin(a)对矩阵a中每个元素取正弦,sin(x)np.cos(a)对矩阵a中每个元素取余弦,cos(x)np.tan(a)对矩阵a中每个元素取正切,tan(x)np.arcsin(a)对矩阵a中每个元素取反正弦,arcsin(x)np.arccos(a)对矩阵a中每个元素取反余弦,arccos(x)np.arctan(a)对矩阵a中每个元素取反正切,arctan(x)np.exp(a)对矩阵a中每个元素取指数函数,exnp.sqrt(a)对矩阵a中每个元素开根号</p><ul><li>当矩阵中的元素不在函数定义域范围内，会产生RuntimeWarning，结果为nan(not a number)</li></ul><p><strong>矩阵乘法（点乘）</strong><br>矩阵乘法必须满足矩阵乘法的条件，即第一个矩阵的列数等于第二个矩阵的行数。 矩阵乘法的函数为 dot 。</p><pre><code class="python">import numpy as npa1 = np.array([[1,2,3],[4,5,6]]) # a1为2*3矩阵a2 = np.array([[1,2],[3,4],[5,6]]) # a2为3*2矩阵print(a1.shape[1]==a2.shape[0]) # True, 满足矩阵乘法条件print(a1.dot(a2)) # a1.dot(a2)相当于matlab中的a1*a2# 而Python中的a1*a2相当于matlab中的a1.*a2# 结果[[22 28] [49 64]]</code></pre><p><strong>矩阵的转置 a.T</strong></p><pre><code class="python">import numpy as npa = np.array([[1,2,3],[4,5,6]])print(a.transpose())# 结果[[1 4] [2 5] [3 6]]</code></pre><p>矩阵的转置还有更简单的方法，就是a.T。</p><pre><code class="python">import numpy as npa = np.array([[1,2,3],[4,5,6]])print(a.T)# 结果[[1 4] [2 5] [3 6]]</code></pre><p><strong>矩阵的逆</strong></p><blockquote><p>设A是数域上的一个n阶方阵，若在相同数域上存在另一个n阶矩阵B，使得： AB=BA=E。 则我们称B是A的逆矩阵，而A则被称为可逆矩阵。</p></blockquote><p>求矩阵的逆需要先导入numpy.linalg，用linalg的inv函数来求逆。矩阵求逆的条件是矩阵应该是方阵。</p><pre><code class="python">import numpy as npimport numpy.linalg as lga = np.array([[1,2,3],[4,5,6],[7,8,9]])print(lg.inv(a))# 结果[[ -4.50359963e+15   9.00719925e+15  -4.50359963e+15] [  9.00719925e+15  -1.80143985e+16   9.00719925e+15] [ -4.50359963e+15   9.00719925e+15  -4.50359963e+15]]a = np.eye(3) # 3阶单位矩阵print(lg.inv(a)) # 单位矩阵的逆为他本身# 结果[[ 1.  0.  0.] [ 0.  1.  0.] [ 0.  0.  1.]]</code></pre><h2 id="矩阵信息获取（如均值等）"><a href="#矩阵信息获取（如均值等）" class="headerlink" title="矩阵信息获取（如均值等）"></a>矩阵信息获取（如均值等）</h2><p><strong>最值</strong><br>获得矩阵中元素最大最小值的函数分别是max和min，可以获得整个矩阵、行或列的最大最小值。</p><pre><code class="python">import numpy as npa = np.array([[1,2,3],[4,5,6]])print(a.max()) #获取整个矩阵的最大值 结果： 6print(a.min()) #结果：1# 可以指定关键字参数axis来获得行最大（小）值或列最大（小）值# axis=0 行方向最大（小）值，即获得每列的最大（小）值# axis=1 列方向最大（小）值，即获得每行的最大（小）值# 例如print(a.max(axis=0))# 结果为 [4 5 6]print(a.max(axis=1))# 结果为 [3 6]# 要想获得最大最小值元素所在的位置，可以通过argmax函数来获得print(a.argmax(axis=1))# 结果为 [2 2]</code></pre><p><strong>平均值</strong></p><p>获得矩阵中元素的平均值可以通过函数mean()。同样地，可以获得整个矩阵、行或列的平均值。</p><pre><code class="python">import numpy as npa = np.array([[1,2,3],[4,5,6]])print(a.mean()) #结果为： 3.5# 同样地，可以通过关键字axis参数指定沿哪个方向获取平均值print(a.mean(axis=0)) # 结果 [ 2.5  3.5  4.5]print(a.mean(axis=1)) # 结果 [ 2.  5.]</code></pre><p><strong>方差</strong></p><p>方差的函数为var(),方差函数var()相当于函数mean(abs(x - x.mean())**2),其中x为矩阵。</p><pre><code class="python">import numpy as npa = np.array([[1,2,3],[4,5,6]])print(a.var()) # 结果 2.91666666667print(a.var(axis=0)) # 结果 [ 2.25  2.25  2.25]print(a.var(axis=1)) # 结果 [ 0.66666667  0.66666667]</code></pre><p><strong>标准差</strong></p><p>标准差的函数为std()。 std()相当于sqrt(mean(abs(x - x.mean())**2))，或相当于sqrt(x.var())。</p><pre><code class="python">import numpy as npa = np.array([[1,2,3],[4,5,6]])print(a.std()) # 结果 1.70782512766print(a.std(axis=0)) # 结果 [ 1.5  1.5  1.5]print(a.std(axis=1)) # 结果 [ 0.81649658  0.81649658]</code></pre><p><strong>中值</strong></p><p>中值指的是将序列按大小顺序排列后，排在中间的那个值，如果有偶数个数，则是排在中间两个数的平均值。中值的函数是median()，调用方法为numpy.median(x,[axis])，axis可指定轴方向，默认axis=None，对所有数取中值。</p><pre><code class="python">import numpy as npx = np.array([[1,2,3],[4,5,6]])print(np.median(x))  # 对所有数取中值# 结果3.5print(np.median(x,axis=0))  # 沿第一维方向取中值# 结果[ 2.5  3.5  4.5]print(np.median(x,axis=1))  # 沿第二维方向取中值# 结果[ 2.  5.]</code></pre><p><strong>求和</strong><br>矩阵求和的函数是sum()，可以对行，列，或整个矩阵求和</p><pre><code class="python">import numpy as npa = np.array([[1,2,3],[4,5,6]])print(a.sum())           # 对整个矩阵求和# 结果 21print(a.sum(axis=0)) # 对行方向求和# 结果 [5 7 9]print(a.sum(axis=1)) # 对列方向求和# 结果 [ 6 15]</code></pre><p><strong>累积和</strong><br>某位置累积和指的是该位置之前(包括该位置)所有元素的和。例如序列[1,2,3,4,5]，其累计和为[1,3,6,10,15]，即第一个元素为1，第二个元素为1+2=3，……，第五个元素为1+2+3+4+5=15。矩阵求累积和的函数是cumsum()，可以对行，列，或整个矩阵求累积和。</p><pre><code class="python">import numpy as npa = np.array([[1,2,3],[4,5,6]])print(a.cumsum())            # 对整个矩阵求累积和# 结果 [ 1  3  6 10 15 21]print(a.cumsum(axis=0))  # 对列方向求累积和# 结果[[1 2 3] [5 7 9]]print(  a.cumsum(axis=1))  # 对行方向求累积和# 结果[[ 1  3  6] [ 4  9 15]]</code></pre><p><strong>极差</strong></p><pre><code class="python">&gt;&gt;&gt;import numpy as np&gt;&gt;&gt;a = np.arange(10)&gt;&gt;&gt;a.ptp()# 结果是9</code></pre><p><strong>百分位数</strong></p><pre><code class="python">numpy.percentile(a, q, axis)</code></pre><p><strong>序号参数及描述</strong>1.a 输入数组2.q 要计算的百分位数，在 0 ~ 100 之间3.axis 沿着它计算百分位数的轴</p><p><strong>加权平均值</strong></p><pre><code class="python">&gt;&gt;&gt; data = range(1,5)&gt;&gt;&gt; data[1, 2, 3, 4]&gt;&gt;&gt; np.average(data)2.5&gt;&gt;&gt; np.average(range(1,11), weights=range(10,0,-1))4.0&gt;&gt;&gt; data = np.arange(6).reshape((3,2))&gt;&gt;&gt; dataarray([[0, 1],       [2, 3],       [4, 5]])&gt;&gt;&gt; np.average(data, axis=1, weights=[1./4, 3./4])array([ 0.75,  2.75,  4.75])&gt;&gt;&gt; np.average(data, weights=[1./4, 3./4])Traceback (most recent call last):...TypeError: Axis must be specified when shapes of a and weights differ.</code></pre><h2 id="Shape-Manipulation"><a href="#Shape-Manipulation" class="headerlink" title="Shape Manipulation"></a>Shape Manipulation</h2><p><strong>Changing the shape of an array</strong></p><pre><code class="python">&gt;&gt;&gt; a = np.floor(10*np.random.random((3,4)))&gt;&gt;&gt; aarray([[ 2.,  8.,  0.,  6.],       [ 4.,  5.,  1.,  1.],       [ 8.,  9.,  3.,  6.]])&gt;&gt;&gt; a.shape(3, 4)</code></pre><p>数组的形状可以用以下方式改变。Note that the following three commands all return a modified array, but do not change the original array:</p><pre><code class="python">&gt;&gt;&gt; a.ravel()  # returns the array, flattenedarray([ 2.,  8.,  0.,  6.,  4.,  5.,  1.,  1.,  8.,  9.,  3.,  6.])&gt;&gt;&gt; a.reshape(6,2)  # returns the array with a modified shapearray([[ 2.,  8.],       [ 0.,  6.],       [ 4.,  5.],       [ 1.,  1.],       [ 8.,  9.],       [ 3.,  6.]])&gt;&gt;&gt; a.T  # returns the array, transposedarray([[ 2.,  4.,  8.],       [ 8.,  5.,  9.],       [ 0.,  1.,  3.],       [ 6.,  1.,  6.]])&gt;&gt;&gt; a.T.shape(4, 3)&gt;&gt;&gt; a.shape(3, 4)</code></pre><p>The reshape function returns its argument with a modified shape, whereas thendarray.resize method modifies the array itself:</p><pre><code class="python">&gt;&gt;&gt; aarray([[ 2.,  8.,  0.,  6.],       [ 4.,  5.,  1.,  1.],       [ 8.,  9.,  3.,  6.]])&gt;&gt;&gt; a.resize((2,6))&gt;&gt;&gt; aarray([[ 2.,  8.,  0.,  6.,  4.,  5.],       [ 1.,  1.,  8.,  9.,  3.,  6.]])</code></pre><p>If a dimension is given as -1 in a reshaping operation, the other dimensions are automatically calculated:</p><pre><code class="python">&gt;&gt;&gt; a.reshape(3,-1)array([[ 2.,  8.,  0.,  6.],       [ 4.,  5.,  1.,  1.],       [ 8.,  9.,  3.,  6.]])</code></pre><p><strong>Splitting one array into several smaller ones</strong><br>Using hsplit, you can split an array along its horizontal axis, either by specifying the number of equally shaped arrays to return, or by specifying the columns after which the division should occur:</p><pre><code class="python">&gt;&gt;&gt; a = np.floor(10*np.random.random((2,12)))&gt;&gt;&gt; aarray([[ 9.,  5.,  6.,  3.,  6.,  8.,  0.,  7.,  9.,  7.,  2.,  7.],       [ 1.,  4.,  9.,  2.,  2.,  1.,  0.,  6.,  2.,  2.,  4.,  0.]])&gt;&gt;&gt; np.hsplit(a,3)   # Split a into 3[array([[ 9.,  5.,  6.,  3.],       [ 1.,  4.,  9.,  2.]]), array([[ 6.,  8.,  0.,  7.],       [ 2.,  1.,  0.,  6.]]), array([[ 9.,  7.,  2.,  7.],       [ 2.,  2.,  4.,  0.]])]</code></pre><p><strong>Copies and Views</strong></p><p>When operating and manipulating arrays, their data is sometimes copied into a new array and sometimes not. This is often a source of confusion for beginners. There are three cases:</p><p><strong>No Copy At All</strong></p><p>a = b,改变b就相当于改变a,或者相反。</p><pre><code class="python">&gt;&gt;&gt; a = np.arange(12)&gt;&gt;&gt; b = a            # no new object is created&gt;&gt;&gt; b is a           # a and b are two names for the same ndarray objectTrue&gt;&gt;&gt; b.shape = 3,4    # changes the shape of a&gt;&gt;&gt; a.shape(3, 4)</code></pre><p><strong>View or Shallow Copy</strong></p><p>Different array objects can share the same data. The view method creates a new array object that looks at the same data.</p><pre><code class="python">&gt;&gt;&gt; c = a.view()&gt;&gt;&gt; c is aFalse&gt;&gt;&gt; c.base is a                        # c is a view of the data owned by aTrue&gt;&gt;&gt; c.flags.owndataFalse&gt;&gt;&gt;&gt;&gt;&gt; c.shape = 2,6                      # a&#39;s shape doesn&#39;t change&gt;&gt;&gt; a.shape(3, 4)&gt;&gt;&gt; c[0,4] = 1234                      # a&#39;s data changes&gt;&gt;&gt; aarray([[   0,    1,    2,    3],       [1234,    5,    6,    7],       [   8,    9,   10,   11]])</code></pre><p>Slicing an array returns a view of it:</p><pre><code class="python">&gt;&gt;&gt; s = a[:,1:3]  # spaces added for clarity; could also be written &quot;s = a[:,1:3]&quot;&gt;&gt;&gt; s[:] = 10    # s[:] is a view of s. Note the difference between s=10 and s[:]=10&gt;&gt;&gt; aarray([[   0,   10,   10,    3],       [1234,   10,   10,    7],       [   8,   10,   10,   11]])</code></pre><p><strong>Deep Copy</strong></p><p>The copy method makes a complete copy of the array and its data.</p><pre><code class="python">&gt;&gt;&gt; d = a.copy()                          # a new array object with new data is created&gt;&gt;&gt; d is aFalse&gt;&gt;&gt; d.base is a                           # d doesn&#39;t share anything with aFalse&gt;&gt;&gt; d[0,0] = 9999&gt;&gt;&gt; aarray([[   0,   10,   10,    3],       [1234,   10,   10,    7],       [   8,   10,   10,   11]])</code></pre><p>numpy关于copy有三种情况，<strong>完全不复制、视图（view）</strong>或者叫浅复制（shadow copy）和<strong>深复制</strong>（deep copy）。而b = a[:]就属于第二种，即视图，这本质上是一种切片操作（slicing），所有的切片操作返回的都是视图。具体来说，b = a[:]会创建一个新的对象b（所以说 id 和a不一样），但是b的数据完全来自于a，和a保持完全一致，换句话说，<strong>b的数据完全由a保管</strong>，他们两个的数据变化是一致的，可以看下面的示例:</p><pre><code class="python">a = np.arange(4)  # array([0, 1, 2, 3])b = a[:]  # array([0, 1, 2, 3])b.flags.owndata  # 返回 False，b 并不保管数据a.flags.owndata  # 返回 True，数据由 a 保管# 改变 a 同时也影响到 ba[-1] = 10  # array([0, 1, 2, 10])b  #  array([0, 1, 2, 10])# 改变 b 同时也影响到 ab[0] = 10  # array([10, 1, 2, 10])a  # array([10, 1, 2, 10])</code></pre><p>b = a 和 b = a[:] 的差别就在于后者会创建新的对象，前者不会。两种方式都会导致a和b的数据相互影响。要想不让a的改动影响到b，可以使用深复制：unique_b = a.copy()</p><p><strong>曼德勃罗</strong></p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltdef mandelbrot( h,w, maxit=20 ):    &quot;&quot;&quot;Returns an image of the Mandelbrot fractal of size (h,w).&quot;&quot;&quot;    y,x = np.ogrid[ -1.4:1.4:h*1j, -2:0.8:w*1j ]    c = x+y*1j    z = c    divtime = maxit + np.zeros(z.shape, dtype=int)    for i in range(maxit):        z = z**2 + c        diverge = z*np.conj(z) &gt; 2**2            # who is diverging        div_now = diverge &amp; (divtime==maxit)  # who is diverging now        divtime[div_now] = i                  # note when        z[diverge] = 2                        # avoid diverging too much    return divtimeplt.imshow(mandelbrot(400,400))plt.show()</code></pre><p><img src="/img/content/numpy/1.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pandas之Dataframe介绍</title>
    <link href="/2020/02/13/panda%E5%92%8CDataframe%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/02/13/panda%E5%92%8CDataframe%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>参考链接：</p><blockquote><p><a href="https://pandas.pydata.org/" target="_blank" rel="noopener">https://pandas.pydata.org/</a><br><a href="https://blog.csdn.net/liufang0001/article/details/77856255" target="_blank" rel="noopener">https://blog.csdn.net/liufang0001/article/details/77856255</a></p></blockquote><h1 id="pandas简介："><a href="#pandas简介：" class="headerlink" title="pandas简介："></a>pandas简介：</h1><pre><code>   pandas是一种Python数据分析的利器，是一个开源的数据分析包。此文讲述常用（关键）部分，其余请查阅[官方文档](https://pandas.pydata.org/pandas-docs/stable/)   使用pandas需要引入约定：(文中将不再赘述)     from pandas import Series, DataFrame     import pandas as pd</code></pre><p>pandas基本数据结构：<br>1. pandas中主要有两种数据结构，分别是：Series和DataFrame。<br>2. Series：一种类似于一维数组的对象，是由一组数据(各种NumPy数据类型)以及一组与之相关的数据标签(即索引)组成。仅由一组数据也可产生简单的Series对象。注意：Series中的索引值是可以重复的。<br>3. DataFrame：一个表格型的数据结构，包含有一组有序的列，每列可以是不同的值类型(数值、字符串、布尔型等)，DataFrame即有行索引也有列索引，可以被看做是由Series组成的字典。</p><h1 id="DataFrame基本函数"><a href="#DataFrame基本函数" class="headerlink" title="DataFrame基本函数"></a>DataFrame基本函数</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code class="python">DataFrame([data, index, columns, dtype, copy]) #构造数据框</code></pre><h2 id="属性和数据"><a href="#属性和数据" class="headerlink" title="属性和数据"></a>属性和数据</h2><pre><code class="python">DataFrame.axes                                #index: 行标签；columns: 列标签DataFrame.as_matrix([columns])                #转换为矩阵DataFrame.dtypes                              #返回数据的类型DataFrame.ftypes                              #返回每一列的 数据类型float64:denseDataFrame.get_dtype_counts()                  #返回数据框数据类型的个数DataFrame.get_ftype_counts()                  #返回数据框数据类型float64:dense的个数DataFrame.select_dtypes([include, include])   #根据数据类型选取子数据框DataFrame.values                              #Numpy的展示方式DataFrame.axes                                #返回横纵坐标的标签名DataFrame.ndim                                #返回数据框的纬度DataFrame.size                                #返回数据框元素的个数DataFrame.shape                               #返回数据框的形状DataFrame.memory_usage()                      #每一列的存储</code></pre><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><pre><code class="python">DataFrame.astype(dtype[, copy, errors])       #转换数据类型DataFrame.copy([deep])                        #deep深度复制数据DataFrame.isnull()                            #以布尔的方式返回空值DataFrame.notnull()                           #以布尔的方式返回非空值</code></pre><h2 id="索引和迭代"><a href="#索引和迭代" class="headerlink" title="索引和迭代"></a>索引和迭代</h2><pre><code class="python">DataFrame.head([n])                           #返回前n行数据DataFrame.at                                  #快速标签常量访问器DataFrame.iat                                 #快速整型常量访问器DataFrame.loc                                 #标签定位，使用名称DataFrame.iloc                                #整型定位，使用数字DataFrame.insert(loc, column, value)          #在特殊地点loc[数字]插入column[列名]某列数据DataFrame.iter()                              #Iterate over infor axisDataFrame.iteritems()                         #返回列名和序列的迭代器DataFrame.iterrows()                          #返回索引和序列的迭代器DataFrame.itertuples([index, name])           #Iterate over DataFrame rows as namedtuples, with index value as first element of the tuple.DataFrame.lookup(row_labels, col_labels)      #Label-based “fancy indexing” function for DataFrame.DataFrame.pop(item)                           #返回删除的项目DataFrame.tail([n])                           #返回最后n行DataFrame.xs(key[, axis, level, drop_level])  #Returns a cross-section (row(s) or column(s)) from the Series/DataFrame.DataFrame.isin(values)                        #是否包含数据框中的元素DataFrame.where(cond[, other, inplace, …])    #条件筛选DataFrame.mask(cond[, other, inplace, …])     #Return an object of same shape as self and whose corresponding entries are from self where cond is False and otherwise are from other.DataFrame.query(expr[, inplace])              #Query the columns of a frame with a boolean expression.</code></pre><h2 id="二元运算"><a href="#二元运算" class="headerlink" title="二元运算"></a>二元运算</h2><pre><code class="python">DataFrame.add(other[,axis,fill_value])        #加法，元素指向DataFrame.sub(other[,axis,fill_value])        #减法，元素指向DataFrame.mul(other[, axis,fill_value])       #乘法，元素指向DataFrame.div(other[, axis,fill_value])       #小数除法，元素指向DataFrame.truediv(other[, axis, level, …])    #真除法，元素指向DataFrame.floordiv(other[, axis, level, …])   #向下取整除法，元素指向DataFrame.mod(other[, axis,fill_value])       #模运算，元素指向DataFrame.pow(other[, axis,fill_value])       #幂运算，元素指向DataFrame.radd(other[, axis,fill_value])      #右侧加法，元素指向DataFrame.rsub(other[, axis,fill_value])      #右侧减法，元素指向DataFrame.rmul(other[, axis,fill_value])      #右侧乘法，元素指向DataFrame.rdiv(other[, axis,fill_value])      #右侧小数除法，元素指向DataFrame.rtruediv(other[, axis, …])          #右侧真除法，元素指向DataFrame.rfloordiv(other[, axis, …])         #右侧向下取整除法，元素指向DataFrame.rmod(other[, axis,fill_value])      #右侧模运算，元素指向DataFrame.rpow(other[, axis,fill_value])      #右侧幂运算，元素指向DataFrame.lt(other[, axis, level])            #类似Array.ltDataFrame.gt(other[, axis, level])            #类似Array.gtDataFrame.le(other[, axis, level])            #类似Array.leDataFrame.ge(other[, axis, level])            #类似Array.geDataFrame.ne(other[, axis, level])            #类似Array.neDataFrame.eq(other[, axis, level])            #类似Array.eqDataFrame.combine(other,func[,fill_value, …]) #Add two DataFrame objects and do not propagate NaN values, so if for aDataFrame.combine_first(other)                #Combine two DataFrame objects and default to non-null values in frame calling the method.</code></pre><h2 id="函数应用-amp-分组-amp-窗口"><a href="#函数应用-amp-分组-amp-窗口" class="headerlink" title="函数应用&amp;分组&amp;窗口"></a>函数应用&amp;分组&amp;窗口</h2><pre><code class="python">DataFrame.apply(func[, axis, broadcast, …])   #应用函数DataFrame.applymap(func)                      #Apply a function to a DataFrame that is intended to operate elementwise, i.e.DataFrame.aggregate(func[, axis])             #Aggregate using callable, string, dict, or list of string/callablesDataFrame.transform(func, *args, **kwargs)    #Call function producing a like-indexed NDFrameDataFrame.groupby([by, axis, level, …])       #分组DataFrame.rolling(window[, min_periods, …])   #滚动窗口DataFrame.expanding([min_periods, freq, …])   #拓展窗口DataFrame.ewm([com, span, halflife,  …])      #指数权重窗口</code></pre><h2 id="描述统计学"><a href="#描述统计学" class="headerlink" title="描述统计学"></a>描述统计学</h2><pre><code class="python">DataFrame.abs()                               #返回绝对值DataFrame.all([axis, bool_only, skipna])      #Return whether all elements are True over requested axisDataFrame.any([axis, bool_only, skipna])      #Return whether any element is True over requested axisDataFrame.clip([lower, upper, axis])          #Trim values at input threshold(s).DataFrame.clip_lower(threshold[, axis])       #Return copy of the input with values below given value(s) truncated.DataFrame.clip_upper(threshold[, axis])       #Return copy of input with values above given value(s) truncated.DataFrame.corr([method, min_periods])         #返回本数据框成对列的相关性系数DataFrame.corrwith(other[, axis, drop])       #返回不同数据框的相关性DataFrame.count([axis, level, numeric_only])  #返回非空元素的个数DataFrame.cov([min_periods])                  #计算协方差DataFrame.cummax([axis, skipna])              #Return cumulative max over requested axis.DataFrame.cummin([axis, skipna])              #Return cumulative minimum over requested axis.DataFrame.cumprod([axis, skipna])             #返回累积DataFrame.cumsum([axis, skipna])              #返回累和DataFrame.describe([percentiles,include, …])  #整体描述数据框DataFrame.diff([periods, axis])               #1st discrete difference of objectDataFrame.eval(expr[, inplace])               #Evaluate an expression in the context of the calling DataFrame instance.DataFrame.kurt([axis, skipna, level, …])      #返回无偏峰度Fisher’s  (kurtosis of normal == 0.0).DataFrame.mad([axis, skipna, level])          #返回偏差DataFrame.max([axis, skipna, level, …])       #返回最大值DataFrame.mean([axis, skipna, level, …])      #返回均值DataFrame.median([axis, skipna, level, …])    #返回中位数DataFrame.min([axis, skipna, level, …])       #返回最小值DataFrame.mode([axis, numeric_only])          #返回众数DataFrame.pct_change([periods, fill_method])  #返回百分比变化DataFrame.prod([axis, skipna, level, …])      #返回连乘积DataFrame.quantile([q, axis, numeric_only])   #返回分位数DataFrame.rank([axis, method, numeric_only])  #返回数字的排序DataFrame.round([decimals])                   #Round a DataFrame to a variable number of decimal places.DataFrame.sem([axis, skipna, level, ddof])    #返回无偏标准误DataFrame.skew([axis, skipna, level, …])      #返回无偏偏度DataFrame.sum([axis, skipna, level, …])       #求和DataFrame.std([axis, skipna, level, ddof])    #返回标准误差DataFrame.var([axis, skipna, level, ddof])    #返回无偏误差 </code></pre><h2 id="从新索引-amp-选取-amp-标签操作"><a href="#从新索引-amp-选取-amp-标签操作" class="headerlink" title="从新索引&amp;选取&amp;标签操作"></a>从新索引&amp;选取&amp;标签操作</h2><pre><code class="python">DataFrame.add_prefix(prefix)                  #添加前缀DataFrame.add_suffix(suffix)                  #添加后缀DataFrame.align(other[, join, axis, level])   #Align two object on their axes with theDataFrame.drop(labels[, axis, level, …])      #返回删除的列DataFrame.drop_duplicates([subset, keep, …])  #Return DataFrame with duplicate rows removed, optionally onlyDataFrame.duplicated([subset, keep])          #Return boolean Series denoting duplicate rows, optionally onlyDataFrame.equals(other)                       #两个数据框是否相同DataFrame.filter([items, like, regex, axis])  #过滤特定的子数据框DataFrame.first(offset)                       #Convenience method for subsetting initial periods of time series data based on a date offset.DataFrame.head([n])                           #返回前n行DataFrame.idxmax([axis, skipna])              #Return index of first occurrence of maximum over requested axis.DataFrame.idxmin([axis, skipna])              #Return index of first occurrence of minimum over requested axis.DataFrame.last(offset)                        #Convenience method for subsetting final periods of time series data based on a date offset.DataFrame.reindex([index, columns])           #Conform DataFrame to new index with optional filling logic, placing NA/NaN in locations having no value in the previous index.DataFrame.reindex_axis(labels[, axis, …])     #Conform input object to new index with optional filling logic, placing NA/NaN in locations having no value in the previous index.DataFrame.reindex_like(other[, method, …])    #Return an object with matching indices to myself.DataFrame.rename([index, columns])            #Alter axes input function or functions.DataFrame.rename_axis(mapper[, axis, copy])   #Alter index and / or columns using input function or functions.DataFrame.reset_index([level, drop, …])       #For DataFrame with multi-level index, return new DataFrame with labeling information in the columns under the index names, defaulting to ‘level_0’, ‘level_1’, etc.DataFrame.sample([n, frac, replace, …])       #返回随机抽样DataFrame.select(crit[, axis])                #Return data corresponding to axis labels matching criteriaDataFrame.set_index(keys[, drop, append ])    #Set the DataFrame index (row labels) using one or more existing columns.DataFrame.tail([n])                           #返回最后几行DataFrame.take(indices[, axis, convert])      #Analogous to ndarray.takeDataFrame.truncate([before, after, axis ])    #Truncates a sorted NDFrame before and/or after some particular index value.</code></pre><h2 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h2><pre><code class="python">DataFrame.dropna([axis, how, thresh, …])      #Return object with labels on given axis omitted where alternately anyDataFrame.fillna([value, method, axis, …])    #填充空值DataFrame.replace([to_replace, value, …])     #Replace values given in ‘to_replace’ with ‘value’.</code></pre><h2 id="从新定型-amp-排序-amp-转变形态"><a href="#从新定型-amp-排序-amp-转变形态" class="headerlink" title="从新定型&amp;排序&amp;转变形态"></a>从新定型&amp;排序&amp;转变形态</h2><pre><code class="python">DataFrame.pivot([index, columns, values])     #Reshape data (produce a “pivot” table) based on column values.DataFrame.reorder_levels(order[, axis])       #Rearrange index levels using input order.DataFrame.sort_values(by[, axis, ascending])  #Sort by the values along either axisDataFrame.sort_index([axis, level, …])        #Sort object by labels (along an axis)DataFrame.nlargest(n, columns[, keep])        #Get the rows of a DataFrame sorted by the n largest values of columns.DataFrame.nsmallest(n, columns[, keep])       #Get the rows of a DataFrame sorted by the n smallest values of columns.DataFrame.swaplevel([i, j, axis])             #Swap levels i and j in a MultiIndex on a particular axisDataFrame.stack([level, dropna])              #Pivot a level of the (possibly hierarchical) column labels, returning a DataFrame (or Series in the case of an object with a single level of column labels) having a hierarchical index with a new inner-most level of row labels.DataFrame.unstack([level, fill_value])        #Pivot a level of the (necessarily hierarchical) index labels, returning a DataFrame having a new level of column labels whose inner-most level consists of the pivoted index labels.DataFrame.melt([id_vars, value_vars, …])      #“Unpivots” a DataFrame from wide format to long format, optionallyDataFrame.T                                   #Transpose index and columnsDataFrame.to_panel()                          #Transform long (stacked) format (DataFrame) into wide (3D, Panel) format.DataFrame.to_xarray()                         #Return an xarray object from the pandas object.DataFrame.transpose(*args, **kwargs)          #Transpose index and columns</code></pre><h2 id="Combining-amp-joining-amp-merging"><a href="#Combining-amp-joining-amp-merging" class="headerlink" title="Combining&amp; joining&amp;merging"></a>Combining&amp; joining&amp;merging</h2><pre><code class="python">DataFrame.append(other[, ignore_index, …])    #追加数据DataFrame.assign(**kwargs)                    #Assign new columns to a DataFrame, returning a new object (a copy) with all the original columns in addition to the new ones.DataFrame.join(other[, on, how, lsuffix, …])  #Join columns with other DataFrame either on index or on a key column.DataFrame.merge(right[, how, on, left_on, …]) #Merge DataFrame objects by performing a database-style join operation by columns or indexes.DataFrame.update(other[, join, overwrite, …]) #Modify DataFrame in place using non-NA values from passed DataFrame.</code></pre><h2 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h2><pre><code class="python">DataFrame.asfreq(freq[, method, how, …])      #将时间序列转换为特定的频次DataFrame.asof(where[, subset])               #The last row without any NaN is taken (or the last row withoutDataFrame.shift([periods, freq, axis])        #Shift index by desired number of periods with an optional time freqDataFrame.first_valid_index()                 #Return label for first non-NA/null valueDataFrame.last_valid_index()                  #Return label for last non-NA/null valueDataFrame.resample(rule[, how, axis, …])      #Convenience method for frequency conversion and resampling of time series.DataFrame.to_period([freq, axis, copy])       #Convert DataFrame from DatetimeIndex to PeriodIndex with desiredDataFrame.to_timestamp([freq, how, axis])     #Cast to DatetimeIndex of timestamps, at beginning of periodDataFrame.tz_convert(tz[, axis, level, copy]) #Convert tz-aware axis to target time zone.DataFrame.tz_localize(tz[, axis, level, …])   #Localize tz-naive TimeSeries to target time zone.</code></pre><h2 id="作图"><a href="#作图" class="headerlink" title="作图"></a>作图</h2><pre><code class="python">DataFrame.plot([x, y, kind, ax, ….])          #DataFrame plotting accessor and methodDataFrame.plot.area([x, y])                   #面积图Area plotDataFrame.plot.bar([x, y])                    #垂直条形图Vertical bar plotDataFrame.plot.barh([x, y])                   #水平条形图Horizontal bar plotDataFrame.plot.box([by])                      #箱图BoxplotDataFrame.plot.density(**kwds)                #核密度Kernel Density Estimate plotDataFrame.plot.hexbin(x, y[, C, …])           #Hexbin plotDataFrame.plot.hist([by, bins])               #直方图HistogramDataFrame.plot.kde(**kwds)                    #核密度Kernel Density Estimate plotDataFrame.plot.line([x, y])                   #线图Line plotDataFrame.plot.pie([y])                       #饼图Pie chartDataFrame.plot.scatter(x, y[, s, c])          #散点图Scatter plotDataFrame.boxplot([column, by, ax, …])        #Make a box plot from DataFrame column optionally grouped by some columns orDataFrame.hist(data[, column, by, grid, …])   #Draw histogram of the DataFrame’s series using matplotlib / pylab.</code></pre><h2 id="转换为其他格式"><a href="#转换为其他格式" class="headerlink" title="转换为其他格式"></a>转换为其他格式</h2><pre><code class="python">DataFrame.from_csv(path[, header, sep, …])    #Read CSV file (DEPRECATED, please use pandas.read_csv() instead).DataFrame.from_dict(data[, orient, dtype])    #Construct DataFrame from dict of array-like or dictsDataFrame.from_items(items[,columns,orient])  #Convert (key, value) pairs to DataFrame.DataFrame.from_records(data[, index, …])      #Convert structured or record ndarray to DataFrameDataFrame.info([verbose, buf, max_cols, …])   #Concise summary of a DataFrame.DataFrame.to_pickle(path[, compression, …])   #Pickle (serialize) object to input file path.DataFrame.to_csv([path_or_buf, sep, na_rep])  #Write DataFrame to a comma-separated values (csv) fileDataFrame.to_hdf(path_or_buf, key, **kwargs)  #Write the contained data to an HDF5 file using HDFStore.DataFrame.to_sql(name, con[, flavor, …])      #Write records stored in a DataFrame to a SQL database.DataFrame.to_dict([orient, into])             #Convert DataFrame to dictionary.DataFrame.to_excel(excel_writer[, …])         #Write DataFrame to an excel sheetDataFrame.to_json([path_or_buf, orient, …])   #Convert the object to a JSON string.DataFrame.to_html([buf, columns, col_space])  #Render a DataFrame as an HTML table.DataFrame.to_feather(fname)                   #write out the binary feather-format for DataFramesDataFrame.to_latex([buf, columns, …])         #Render an object to a tabular environment table.DataFrame.to_stata(fname[, convert_dates, …]) #A class for writing Stata binary dta files from array-like objectsDataFrame.to_msgpack([path_or_buf, encoding]) #msgpack (serialize) object to input file pathDataFrame.to_sparse([fill_value, kind])       #Convert to SparseDataFrameDataFrame.to_dense()                          #Return dense representation of NDFrame (as opposed to sparse)DataFrame.to_string([buf, columns, …])        #Render a DataFrame to a console-friendly tabular output.DataFrame.to_clipboard([excel, sep])          #Attempt to write text representation of object to the system clipboard This can be pasted into Excel, for example.</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物联网数据传输、存储和展示</title>
    <link href="/2020/02/13/%E7%89%A9%E8%81%94%E7%BD%91%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%AD%98%E5%82%A8-EMQ-telegraf-influxdb%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/02/13/%E7%89%A9%E8%81%94%E7%BD%91%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%AD%98%E5%82%A8-EMQ-telegraf-influxdb%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="一、开源MQTT消息服务器——EMQ"><a href="#一、开源MQTT消息服务器——EMQ" class="headerlink" title="一、开源MQTT消息服务器——EMQ"></a>一、开源MQTT消息服务器——EMQ</h1><p>官网链接：<a href="https://www.emqx.io/cn/" target="_blank" rel="noopener">https://www.emqx.io/cn/</a><br>官方文档：<a href="https://docs.emqx.io/broker/latest/cn/" target="_blank" rel="noopener">https://docs.emqx.io/broker/latest/cn/</a><br><img src="/img/content/chuanshu/emq.png" srcset="/img/loading.gif" alt=""></p><p>EMQ X (Erlang/Enterprise/Elastic MQTT Broker) 是基于 Erlang/OTP 语言平台开发，支持大规模连接和分布式集群，发布订阅模式的开源 MQTT 消息服务器。</p><blockquote><p>注解</p></blockquote><blockquote><p>3.0 版本开始 emqttd 消息服务器自正式更名为 EMQ X</p></blockquote><p>EMQ X 消息服务器完整支持 MQTT V3.1/V3.1.1/V5.0 版本协议规范，并扩展支持 MQTT-SN 、WebSocket、CoAP、LwM2M、Stomp 以及私有 TCP/UDP 协议。EMQ X 消息服务器支持单节点100万连接与多节点分布式集群。</p><p>EMQ X 消息服务器为大规模设备连接 (C1000K+) 的物联网、车联网、智能硬件、移动推送、移动消息等应用，提供完全开放源码、安装部署简便、企业级稳定可靠、可弹性扩展、易于定制开发的 MQTT 消息服务器。</p><blockquote><p>注解</p></blockquote><blockquote><p>MQTT-SN、CoAP 协议已在2.0-rc.1版本发布，LwM2M、LoRaWan 协议在 3.0 版本发布。</p></blockquote><p><img src="/img/content/chuanshu/emqtt.png" srcset="/img/loading.gif" alt=""></p><h1 id="二、数据采集工具——Telegraf"><a href="#二、数据采集工具——Telegraf" class="headerlink" title="二、数据采集工具——Telegraf"></a>二、数据采集工具——Telegraf</h1><p>官网链接：<a href="https://www.influxdata.com/time-series-platform/telegraf/" target="_blank" rel="noopener">https://www.influxdata.com/time-series-platform/telegraf/</a><br><img src="/img/content/chuanshu/telegraf.png" srcset="/img/loading.gif" alt=""></p><p>Telegraf 是收集和报告指标和数据的代理。</p><p>Telegraf是TICK Stack的一部分，是一个插件驱动的服务器代理，用于收集和报告指标。</p><p>Telegraf 集成了直接从其运行的容器和系统中提取各种指标，事件和日志，从第三方API提取指标，甚至通过StatsD和Kafka消费者服务监听指标。</p><p>它还具有输出插件，可将指标发送到各种其他数据存储，服务和消息队列，包括InfluxDB，Graphite，OpenTSDB，Datadog，Librato，Kafka，MQTT，NSQ等等。</p><p><img src="/img/content/chuanshu/telegraf_tushi.png" srcset="/img/loading.gif" alt=""></p><h1 id="三、时序数据库——Influxdb"><a href="#三、时序数据库——Influxdb" class="headerlink" title="三、时序数据库——Influxdb"></a>三、时序数据库——Influxdb</h1><p>官网链接：<a href="https://www.influxdata.com/products/influxdb-overview/" target="_blank" rel="noopener">https://www.influxdata.com/products/influxdb-overview/</a><br><img src="/img/content/chuanshu/influxdb.png" srcset="/img/loading.gif" alt=""></p><p>Influxdb 是一个开源的分布式时序、时间和指标数据库，使用 Go 语言编写，无需外部依赖。</p><h2 id="3-1-Influxdb特性："><a href="#3-1-Influxdb特性：" class="headerlink" title="3.1 Influxdb特性："></a>3.1 Influxdb特性：</h2><p>①、基于时间序列，支持与时间有关的相关函数（如最大，最小，求和等）；</p><p>②、可度量性：你可以实时对大量数据进行计算；</p><p>③、基于事件：它支持任意的事件数据；</p><h2 id="3-2-为什么要用telegraf和influxdb？"><a href="#3-2-为什么要用telegraf和influxdb？" class="headerlink" title="3.2 为什么要用telegraf和influxdb？"></a>3.2 为什么要用telegraf和influxdb？</h2><p>①、在数据采集和平台监控系统中，Telegraf 可以采集多种组件的运行信息，而不需要自己手写脚本定时采集，降低数据获取的难度；</p><p>②、Telegraf 配置简单，只要有基本的 Linux 基础即可快速上手；</p><p>③、Telegraf 按照时间序列采集数据，数据结构中包含时序信息，influxdb就是为此类数据设计而来，使用 Influxdb 可以针采集得到的数据完成各种分析计算操作。</p><h1 id="四、-可视化工具——Grafana"><a href="#四、-可视化工具——Grafana" class="headerlink" title="四、 可视化工具——Grafana"></a>四、 可视化工具——Grafana</h1><p>官网地址：<a href="https://grafana.com/" target="_blank" rel="noopener">https://grafana.com/</a><br><img src="/img/content/chuanshu/grafana.png" srcset="/img/loading.gif" alt=""></p><p>Grafana是一个跨平台的开源的度量分析和可视化工具，可以通过将采集的数据查询然后可视化的展示，并及时通知。它主要有以下六大特点：</p><p>1、展示方式：快速灵活的客户端图表，面板插件有许多不同方式的可视化指标和日志，官方库中具有丰富的仪表盘插件，比如热图、折线图、图表等多种展示方式；</p><p>2、数据源：Graphite，InfluxDB，OpenTSDB，Prometheus，Elasticsearch，CloudWatch和KairosDB等；</p><p>3、通知提醒：以可视方式定义最重要指标的警报规则，Grafana将不断计算并发送通知，在数据达到阈值时通过Slack、PagerDuty等获得通知；</p><p>4、混合展示：在同一图表中混合使用不同的数据源，可以基于每个查询指定数据源，甚至自定义数据源；</p><p>5、注释：使用来自不同数据源的丰富事件注释图表，将鼠标悬停在事件上会显示完整的事件元数据和标记；</p><p>6、过滤器：Ad-hoc过滤器允许动态创建新的键/值过滤器，这些过滤器会自动应用于使用该数据源的所有查询。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mqtt</tag>
      
      <tag>influxdb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物联网传输协议：mqtt入门</title>
    <link href="/2020/02/13/mqtt%E6%A6%82%E8%BF%B0%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/02/13/mqtt%E6%A6%82%E8%BF%B0%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h1><p> MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的“轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p><p> MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。<br><img src="/img/content/mqtt/1.png" srcset="/img/loading.gif" alt=""></p><h1 id="二、设计规范"><a href="#二、设计规范" class="headerlink" title="二、设计规范"></a>二、设计规范</h1><p>由于物联网的环境是非常特别的，所以MQTT遵循以下设计原则：</p><p>（1）精简，不添加可有可无的功能；</p><p>（2）发布/订阅（Pub/Sub）模式，方便消息在传感器之间传递；</p><p>（3）允许用户动态创建主题，零运维成本；</p><p>（4）把传输量降到最低以提高传输效率；</p><p>（5）把低带宽、高延迟、不稳定的网络等因素考虑在内；</p><p>（6）支持连续的会话控制；</p><p>（7）理解客户端计算能力可能很低；</p><p>（8）提供服务质量管理；</p><p>（9）假设数据不可知，不强求传输数据的类型与格式，保持灵活性。</p><h1 id="三、主要特性"><a href="#三、主要特性" class="headerlink" title="三、主要特性"></a>三、主要特性</h1><p> MQTT协议工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性：</p><p>（1）使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。</p><p> 这一点很类似于XMPP，但是MQTT的信息冗余远小于XMPP，,因为XMPP使用XML格式文本来传递数据。</p><p>（2）对负载内容屏蔽的消息传输。</p><p>（3）使用TCP/IP提供网络连接。</p><p> 主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。</p><p>（4）有三种消息发布服务质量：</p><p> “至多一次”，消息发布完全依赖底层TCP/IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。</p><p> “至少一次”，确保消息到达，但消息重复可能会发生。</p><p> “只有一次”，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别。在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP的推送，确保用户收到且只会收到一次。</p><p>（5）小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量。</p><p> 这就是为什么在介绍里说它非常适合“在物联网领域，传感器与服务器的通信，信息的收集”，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了。</p><p>（6）使用Last Will和Testament特性通知有关各方客户端异常中断的机制。</p><p>Last Will：即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接。</p><p>Testament：遗嘱机制，功能类似于Last Will。</p><h1 id="四、MQTT协议原理"><a href="#四、MQTT协议原理" class="headerlink" title="四、MQTT协议原理"></a>四、MQTT协议原理</h1><h2 id="4-1-MQTT协议实现方式"><a href="#4-1-MQTT协议实现方式" class="headerlink" title="4.1 MQTT协议实现方式"></a>4.1 MQTT协议实现方式</h2><p> 实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。</p><p>MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：</p><p>（1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）；</p><p>（2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。</p><h2 id="4-2-网络传输与应用消息"><a href="#4-2-网络传输与应用消息" class="headerlink" title="4.2 网络传输与应用消息"></a>4.2 网络传输与应用消息</h2><p> MQTT会构建底层网络传输：它将建立客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输。</p><p>当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（QoS）和主题名（Topic）相关连。</p><h2 id="4-3MQTT客户端"><a href="#4-3MQTT客户端" class="headerlink" title="4.3MQTT客户端"></a>4.3MQTT客户端</h2><p> 一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以：</p><p>（1）发布其他客户端可能会订阅的信息；</p><p>（2）订阅其它客户端发布的消息；</p><p>（3）退订或删除应用程序的消息；</p><p>（4）断开与服务器连接。</p><h2 id="4-4-MQTT服务器"><a href="#4-4-MQTT服务器" class="headerlink" title="4.4 MQTT服务器"></a>4.4 MQTT服务器</h2><p> MQTT服务器以称为“消息代理”（Broker），可以是一个应用程序或一台设备。它是位于消息发布者和订阅者之间，它可以：</p><p>（1）接受来自客户的网络连接；</p><p>（2）接受客户发布的应用信息；</p><p>（3）处理来自客户端的订阅和退订请求；</p><p>（4）向订阅的客户转发应用程序消息。</p><h2 id="4-5-MQTT协议中的订阅、主题、会话"><a href="#4-5-MQTT协议中的订阅、主题、会话" class="headerlink" title="4.5 MQTT协议中的订阅、主题、会话"></a>4.5 MQTT协议中的订阅、主题、会话</h2><p>一、订阅（Subscription）</p><p> 订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每一个会话中的每个订阅都有一个不同的主题筛选器。</p><p>二、会话（Session）</p><p> 每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。</p><p>三、主题名（Topic Name）</p><p> 连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。</p><p>四、主题筛选器（Topic Filter）</p><p> 一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。</p><p>五、负载（Payload）</p><p> 消息订阅者所具体接收的内容。</p><h2 id="4-6-MQTT协议中的方法"><a href="#4-6-MQTT协议中的方法" class="headerlink" title="4.6 MQTT协议中的方法"></a>4.6 MQTT协议中的方法</h2><p> MQTT协议中定义了一些方法（也被称为动作），来于表示对确定资源所进行操作。这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现。通常来说，资源指服务器上的文件或输出。主要方法有：</p><p>（1）Connect。等待与服务器建立连接。</p><p>（2）Disconnect。等待MQTT客户端完成所做的工作，并与服务器断开TCP/IP会话。</p><p>（3）Subscribe。等待完成订阅。</p><p>（4）UnSubscribe。等待服务器取消客户端的一个或多个topics订阅。</p><p>（5）Publish。MQTT客户端发送消息请求，发送完成后返回应用程序线程。</p><h1 id="五、MQTT协议数据包结构"><a href="#五、MQTT协议数据包结构" class="headerlink" title="五、MQTT协议数据包结构"></a>五、MQTT协议数据包结构</h1><p> 在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Variable header）、消息体（payload）三部分构成。MQTT数据包结构如下：</p><p>（1）固定头（Fixed header）。存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识。</p><p>（2）可变头（Variable header）。存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容。</p><p>（3）消息体（Payload）。存在于部分MQTT数据包中，表示客户端收到的具体内容。</p><h2 id="5-1-MQTT固定头"><a href="#5-1-MQTT固定头" class="headerlink" title="5.1 MQTT固定头"></a>5.1 MQTT固定头</h2><p>固定头存在于所有MQTT数据包中，其结构如下：</p><h3 id="5-1-1-MQTT数据包类型"><a href="#5-1-1-MQTT数据包类型" class="headerlink" title="5.1.1 MQTT数据包类型"></a>5.1.1 MQTT数据包类型</h3><p>位置：Byte 1中bits 7-4。</p><p>相于一个4位的无符号值，类型、取值及描述如下：</p><h3 id="5-1-2-标识位"><a href="#5-1-2-标识位" class="headerlink" title="5.1.2 标识位"></a>5.1.2 标识位</h3><p>位置：Byte 1中bits 3-0。</p><p> 在不使用标识位的消息类型中，标识位被作为保留位。如果收到无效的标志时，接收端必须关闭网络连接：</p><p>（1）DUP：发布消息的副本。用来在保证消息的可靠传输，如果设置为1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送。</p><p>（2）QoS：发布消息的服务质量，即：保证消息传递的次数</p><p><img src="/img/content/mqtt/2.png" srcset="/img/loading.gif" alt=""></p><p>（3）RETAIN： 发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放。</p><h3 id="5-1-3-剩余长度（Remaining-Length）"><a href="#5-1-3-剩余长度（Remaining-Length）" class="headerlink" title="5.1.3 剩余长度（Remaining Length）"></a>5.1.3 剩余长度（Remaining Length）</h3><p>地址：Byte 2。</p><p> 固定头的第二字节用来保存变长头部和消息体的总大小的，但不是直接保存的。这一字节是可以扩展，其保存机制，前7位用于保存长度，后一部用做标识。当最后一位为1时，表示长度不足，需要使用二个字节继续保存。例如：计算出后面的大小为0</p><h2 id="5-2-MQTT可变头"><a href="#5-2-MQTT可变头" class="headerlink" title="5.2 MQTT可变头"></a>5.2 MQTT可变头</h2><p> MQTT数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是作为包的标识：</p><p> 很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有：PUBLISH (QoS &gt; 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK。</p><h2 id="5-3-Payload消息体"><a href="#5-3-Payload消息体" class="headerlink" title="5.3 Payload消息体"></a>5.3 Payload消息体</h2><p> Payload消息体位MQTT数据包的第三部分，包含CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息：</p><p>（1）CONNECT，消息体内容主要是：客户端的ClientID、订阅的Topic、Message以及用户名和密码。</p><p>（2）SUBSCRIBE，消息体内容是一系列的要订阅的主题以及QoS。</p><p>（3）SUBACK，消息体内容是服务器对于SUBSCRIBE所申请的主题及QoS进行确认和回复。</p><p>（4）UNSUBSCRIBE，消息体内容是要订阅的主题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mqtt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器定时器配置</title>
    <link href="/2020/02/13/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/02/13/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="1、-crontab命令概念"><a href="#1、-crontab命令概念" class="headerlink" title="1、  crontab命令概念"></a>1、 crontab命令概念</h2><p><strong>crontab命令用于设置周期性被执行的指令。</strong>该命令从标准输入设备读取指令，并将其存放于“crontab”文件中，以供之后读取和执行。</p><p><strong>cron 系统调度进程。</strong> 可以使用它在每天的非高峰负荷时间段运行作业，或在一周或一月中的不同时段运行。cron是系统主要的调度进程，可以在无需人工干预的情况下运行作业。</p><p>crontab命令允许用户提交、编辑或删除相应的作业。每一个用户都可以有一个crontab文件来保存调度信息。系统管理员可以通过/etc/cron.deny 和 /etc/cron.allow 这两个文件来禁止或允许</p><p>用户拥有自己的crontab文件。</p><h2 id="2、检查是否安装了crontab，如果提示未安装请自行安装，crontab安装包在系统光盘里面的pacekage文件夹crontabs安装包。"><a href="#2、检查是否安装了crontab，如果提示未安装请自行安装，crontab安装包在系统光盘里面的pacekage文件夹crontabs安装包。" class="headerlink" title="2、检查是否安装了crontab，如果提示未安装请自行安装，crontab安装包在系统光盘里面的pacekage文件夹crontabs安装包。"></a>2、检查是否安装了crontab，如果提示未安装请自行安装，crontab安装包在系统光盘里面的pacekage文件夹crontabs安装包。</h2><p><img src="/img/content/dingshi/1.png" srcset="/img/loading.gif" alt=""></p><h2 id="3、-crontab服务启动与关闭。"><a href="#3、-crontab服务启动与关闭。" class="headerlink" title="3、  crontab服务启动与关闭。"></a>3、 crontab服务启动与关闭。</h2><p><img src="/img/content/dingshi/2.png" srcset="/img/loading.gif" alt=""></p><h2 id="4、-全局配置文件："><a href="#4、-全局配置文件：" class="headerlink" title="4、  全局配置文件："></a>4、 全局配置文件：</h2><p>crontab在/etc目录下面存在cron.hourly,cron.daily,cron.weekly,cron.monthly,cron.d五个目录和crontab,cron.deny二个文件。</p><p><img src="/img/content/dingshi/3.png" srcset="/img/loading.gif" alt=""></p><p><strong>cron.daily</strong>是每天执行一次的job</p><p><strong>cron.monthly</strong>是每月执行一次的job</p><p><strong>cron.hourly</strong>是每个小时执行一次的job</p><p><strong>cron.d</strong>是系统自动定期需要做的任务</p><p><strong>crontab</strong>是设定定时任务执行文件</p><p><strong>cron.deny</strong>文件就是用于控制不让哪些用户使用Crontab的功能</p><h2 id="5、-用户配置文件："><a href="#5、-用户配置文件：" class="headerlink" title="5、  用户配置文件："></a>5、 用户配置文件：</h2><p>每个用户都有自己的cron配置文件,通过crontab -e 就可以编辑,一般情况下我们编辑好用户的cron配置文件保存退出后,系统会自动就存放于/var/spool/cron/目录中,文件以用户名命名.linux的cron服务是每隔一分钟去读取一次/var/spool/cron,/etc/crontab,/etc/cron.d下面所有的内容.</p><p><img src="/img/content/dingshi/4.png" srcset="/img/loading.gif" alt=""></p><h2 id="6、-crontab文件格式："><a href="#6、-crontab文件格式：" class="headerlink" title="6、  crontab文件格式："></a>6、 crontab文件格式：</h2><ul><li><ul><li><ul><li><ul><li><ul><li>command</li></ul></li></ul></li></ul></li></ul></li></ul><p>minute hour day month week command</p><p>分 时 天 月 星期 命令</p><p><img src="/img/content/dingshi/5.png" srcset="/img/loading.gif" alt=""></p><p><strong>minute</strong>： 表示分钟，可以是从0到59之间的任何整数。</p><p><strong>hour</strong>：表示小时，可以是从0到23之间的任何整数。</p><p><strong>day</strong>：表示日期，可以是从1到31之间的任何整数。</p><p><strong>month</strong>：表示月份，可以是从1到12之间的任何整数。</p><p><strong>week</strong>：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</p><p><strong>command</strong>：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</p><h2 id="7、-特殊字符"><a href="#7、-特殊字符" class="headerlink" title="7、 特殊字符:"></a>7、 特殊字符:</h2><p>星号（*）：代表每的意思，例如month字段如果是星号，则表示每月都执行该命令操作。</p><p>逗号（,）：表示分隔时段的意思，例如，“1,3,5,7,9”。</p><p>中杠（-）：表示一个时间范围，例如“2-6”表示“2,3,4,5,6”。</p><p>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</p><h2 id="8、在home目录下编写一个test-sh脚本，脚本功能是把-home下ifcfg-eth0这个文本复制到-mnt目录下。"><a href="#8、在home目录下编写一个test-sh脚本，脚本功能是把-home下ifcfg-eth0这个文本复制到-mnt目录下。" class="headerlink" title="8、在home目录下编写一个test.sh脚本，脚本功能是把/home下ifcfg-eth0这个文本复制到/mnt目录下。"></a>8、在home目录下编写一个test.sh脚本，脚本功能是把/home下ifcfg-eth0这个文本复制到/mnt目录下。</h2><p><img src="/img/content/dingshi/6.png" srcset="/img/loading.gif" alt=""></p><h2 id="9、运行crontab-–e-编写一条定时任务-5-home-test-sh-在每5分钟执行一次test-sh脚本。"><a href="#9、运行crontab-–e-编写一条定时任务-5-home-test-sh-在每5分钟执行一次test-sh脚本。" class="headerlink" title="9、运行crontab –e 编写一条定时任务 */5 * * * * /home/test.sh 在每5分钟执行一次test.sh脚本。"></a>9、运行crontab –e 编写一条定时任务 */5 * * * * /home/test.sh 在每5分钟执行一次test.sh脚本。</h2><p><img src="/img/content/dingshi/7.png" srcset="/img/loading.gif" alt=""></p><p><img src="/img/content/dingshi/8.png" srcset="/img/loading.gif" alt=""></p><h2 id="10、查询当前用户定时任务或删除当前用户定时任务。"><a href="#10、查询当前用户定时任务或删除当前用户定时任务。" class="headerlink" title="10、查询当前用户定时任务或删除当前用户定时任务。"></a>10、查询当前用户定时任务或删除当前用户定时任务。</h2><p><img src="/img/content/dingshi/9.png" srcset="/img/loading.gif" alt=""></p><h2 id="11、设置crond开机自动启动。"><a href="#11、设置crond开机自动启动。" class="headerlink" title="11、设置crond开机自动启动。"></a>11、设置crond开机自动启动。</h2><p><img src="/img/content/dingshi/10.png" srcset="/img/loading.gif" alt=""></p><h2 id="12、实例："><a href="#12、实例：" class="headerlink" title="12、实例："></a>12、实例：</h2><p><img src="/img/content/dingshi/11.png" srcset="/img/loading.gif" alt=""></p><p>##每月每天凌晨3点30分和中午12点20分执行test.sh脚本</p><p>30 3,12 * * * /home/test.sh</p><p>##每月每天每隔6小时的每30分钟执行test.sh脚本</p><p><strong>30 */6 * * * /home/test.sh</strong></p><p>##每月每天早上8点到下午18点每隔2小时的每30分钟执行test.sh脚本</p><p><strong>30 8-18/2 * * * /etc/init.d/network restart</strong></p><p>##每月每天晚上21点30分执行test.sh脚本</p><p><strong>30 21 * * * /etc/init.d/network restart</strong></p><p>##每月1号、10号、22号凌晨4点45分执行test.sh脚本</p><p><strong>45 4 1,10,22 * * /etc/init.d/network restart</strong></p><p>##8月份周一、周日凌晨1点10分执行test.sh脚本</p><p><strong>10 1 * 8 6,0 /etc/init.d/network restart</strong></p><p>##每月每天每小时整点执行test.sh脚本</p><p><strong>00 */1 * * * /etc/init.d/network restart</strong></p><p><strong>**</strong>定时任务书写要领<strong>**</strong></p><p><strong>要领1</strong>：定时任务要加注释</p><p><strong>要领2</strong>：定时任务命令或脚本结尾加 &amp;&gt;/dev/null 或 &gt;/dev/null 2&gt;&amp;1 或 1&gt;/dev/null 2&gt;/dev/null</p><p><strong>要领3</strong>：定时任务执行shell脚本前加/bin/sh，定时任务执行shell脚本不必添加执行权限</p><p><strong>要领4</strong>：定时任务命令或程序尽量写到脚本里，定时任务只要执行脚本即可</p><pre><code>     注意操作步骤：</code></pre><p>　　（1）、命令行执行</p><p>　　（2）、编写脚本</p><p>　　（3）、测试脚本</p><p>　　（4）、设置定时任务</p><p><strong>要领5</strong>：生产任务程序不要随意打印输出信息</p><p><strong>要领6</strong>：定时任务执行的脚本要规范路径 (例如 /server/script)</p><p><strong>要领7</strong>：配置定时任务要规范操作过程</p><p><strong>要领8</strong>：定时任务执行特殊的字符需要进行转义，否则会报错，例如 百分号% 转义 %</p><p><strong>要领9</strong>：定时任务脚本中如果涉及使用到环境变量，必须在脚本中重新定义，不然，定时任务识别不了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>centos7.x下部署django项目</title>
    <link href="/2020/02/13/Linux-Server%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"/>
    <url>/2020/02/13/Linux-Server%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p><strong>更新系统依赖包</strong></p><pre><code>yum update -y</code></pre><p><strong>安装依赖包</strong></p><pre><code>yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-develgcc</code></pre><h2 id="安装python3解释器"><a href="#安装python3解释器" class="headerlink" title="安装python3解释器"></a>安装python3解释器</h2><p><strong>下载python3.7安装包</strong></p><pre><code>wget https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz</code></pre><p><strong>解压安装包</strong></p><pre><code>tar -zxvf Python-3.7.3.tgz</code></pre><p><strong>创建python解释器安装位置</strong></p><pre><code>sudo mkdir /usr/local/python3</code></pre><p><strong>cd 到解压包中编译python解释器</strong></p><pre><code>./configure --prefix=/usr/local/python3 --enable optimizations</code></pre><p><strong>安装解释器</strong></p><pre><code>make &amp;&amp; make install </code></pre><p>这里可能会报 <code>ModuleNotFoundError: module named &quot;_ctypes&quot; make : *** [install] 错误1</code></p><p>缺少安装依赖包解决办法：<code>yum -y install libffi-devel 重新 make &amp;&amp; make install</code></p><p><strong>创建软链接</strong></p><pre><code>ln -s /usr/local/python3/bin/python3.7 /usr/bin/python3ln -s /usr/local/python3/bin/pip3 /usr/bin/pip</code></pre><p><strong>测试</strong></p><pre><code>python3 -Vpip -V</code></pre><p><img src="/img/content/linux/1.png" srcset="/img/loading.gif" alt=""></p><p><img src="/img/content/linux/2.png" srcset="/img/loading.gif" alt=""></p><h2 id="Mysql配置安装"><a href="#Mysql配置安装" class="headerlink" title="Mysql配置安装"></a>Mysql配置安装</h2><p><strong>下载</strong></p><pre><code>wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm</code></pre><p><strong>安装mysql-community-release-el7-5.noarch.rpm包</strong></p><pre><code>sudo rpm -ivh mysql-community-release-el7-5.noarch.rpm</code></pre><p><strong>安装mysql</strong></p><pre><code>sudo yum install mysql-server</code></pre><p><strong>重置密码</strong></p><blockquote><p>先修改权限问题：</p></blockquote><pre><code>sudo chown -R openscanner:openscanner /var/lib/mysql</code></pre><blockquote><p>重启服务：</p></blockquote><pre><code>service mysqld restart</code></pre><blockquote><p>重置登录密码</p></blockquote><pre><code>mysql -u rootmysql &gt; UPDATE mysql.user SET Password=PASSWORD(&#39;123456&#39;) WHERE User= &#39;root&#39;;FLUSH PRIVILEGES;</code></pre><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p><strong>方法一</strong></p><pre><code>pip install pipenv</code></pre><p>切换到项目所在目录：</p><pre><code>pipenv shell  #会生成一个项目同名的依赖环境</code></pre><p><strong>方法二</strong></p><pre><code>pip install virtualenvpip3 install virtualenvwrapperfind / -name &#39;virtualenvwrapper.sh&#39;  #找到wrapper安装位置mkdir  /home/ .virtualenvs   #创建virtualenvwrapper存放位置</code></pre><p>编辑 . bashrc 文件末尾添加以下代码</p><pre><code>if&quot;&quot;exportWORKON_HOME=/home/.virtualenvsexportVIRTUALENVWRAPPER_PYTHON=/usr/bin/python3source/usr/local/python3/bin/virtualenvwrapper.shfisource .bashrc   #更新代码</code></pre><p><strong>相关命令</strong></p><pre><code>mkvirtualenv name -p python3   #创建环境rmvirtualenv name  #删除环境workon  name  #进入环境</code></pre><h2 id="gunicorn安装配置"><a href="#gunicorn安装配置" class="headerlink" title="gunicorn安装配置"></a>gunicorn安装配置</h2><p><strong>安装</strong></p><pre><code>pip install gunicorn</code></pre><p><strong>配置</strong></p><p>项目settings.py</p><pre><code>install_app {&quot;&quot;&quot;&quot;gunicorn&quot;, &quot;&quot;&quot;}</code></pre><p>项目文件配置-gunicorn.py</p><pre><code>import multiprocessingbind = &#39;0.0.0.0:8000&#39; #监听端口workers = 10  worker_connections = 200  pidfile = &#39;/root/DjangoBlog/logs/gunicorn.pid&#39; #pid文件proc_name = &quot;DjangoBlog&quot;  reload = True   #重载errorlog = &quot;/root/DjangoBlog/logs/guni.log&quot;  #报错日志  loglevel = &#39;debug&#39;  #debug等级</code></pre><h2 id="Supervisor安装配置"><a href="#Supervisor安装配置" class="headerlink" title="Supervisor安装配置"></a>Supervisor安装配置</h2><p><strong>安装</strong></p><pre><code>pip install supervisor</code></pre><p><strong>配置文件生成</strong></p><pre><code>mkdir -m 755 -p /etc/supervisor/mkdir -m 755 conf.decho_supervisord_conf &gt; /etc/supervisor/supervisord.conf</code></pre><p><strong>配置需要启动的项目</strong></p><pre><code>cd   /etc/supervisor/conf.d</code></pre><p>创建DjangoBlog.conf文件</p><pre><code>[program:Dblog] # 程序名字：启动/停止app_name部分directory=/root/DjangoBlog #项目目录command = /home/.virtualenvs/Dblong/bin/gunicorn  -c /root/DjangoBlog/bin/guniconf.py  DjangoBlog.wsgi:application#程序运行命令配置了gunicornautostart = true  autorestart = true #程序自动重启user=root   #用户redirect_stderr = true  stdout_logfile = /root/DjangoBlog/logs/robot.logstderr_logfile=/root/DjangoBlog/logs/err.log</code></pre><p><strong>运行</strong></p><pre><code>supervisord -c /etc/supervisor/supervisord.conf</code></pre><p><strong>相关命令</strong></p><p>​ 启动程序</p><pre><code>supervisorctl start program_name  </code></pre><p>关闭程序</p><pre><code>supervisorctl stop program_name  supervisorctl shutdown</code></pre><p>查看运行</p><pre><code>supervisorctl status</code></pre><h2 id="Nginx相关配置"><a href="#Nginx相关配置" class="headerlink" title="Nginx相关配置"></a>Nginx相关配置</h2><p><strong>nginx安装</strong></p><p><strong>方法一</strong></p><p>下载</p><pre><code>wget http://nginx.org/download/nginx-1.9.9.tar.gz </code></pre><p>解压</p><pre><code>tar -zxvf nginx-1.9.9.tar.gz </code></pre><p>编译:cd 到解压目录下</p><pre><code>./configure --prefix=/usr --sbin-path=/usr/sbin/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --pid-path=/var/run/nginx/nginx.pid --lock-path=/var/lock/nginx.lock --user=nginx --group=nginx --with-http_ssl_module --with-http_flv_module --with-http_gzip_static_module --http-log-path=/var/log/nginx/access.log --http-client-body-temp-path=/var/tem/nginx/client --http-proxy-temp-path=/var/tem/nginx/proxy --http-fastcgi-temp-path=/var/tem/nginx/fcgi --with-http_stub_status_module</code></pre><p>安装</p><pre><code>make &amp;&amp; make install</code></pre><p><strong>方法二</strong></p><pre><code>sudo apt-get install nginx   #安装sudo service nginx start  #运行</code></pre><p>启动</p><pre><code>nginx -c /etc/nginx/nginx.conf</code></pre><p><strong>报错1</strong><code>[emerg] getpwnam(&quot;nginx&quot;) failed</code><br><strong>解决</strong></p><pre><code>useradd -s /sbin/nologin -M nginx id nginx </code></pre><p><strong>报错2</strong> <code>[emerg] mkdir() &quot;/var/temp/nginx/client&quot; failed (2: No such file or directory)</code><br><strong>解决</strong></p><pre><code>sudo mkdir -p /var/tem/nginx/client</code></pre><p><strong>nginx命令</strong></p><pre><code>service nginx start   #启动service nginx stop    #停止service nginx reload  #重启nginx -s reload  #重启nginx -t # 测试</code></pre><p>测试是否安装成功：</p><pre><code>nginx -t</code></pre><p><img src="/img/content/linux/3.png" srcset="/img/loading.gif" alt=""></p><p>至此nginx安装完成，开始相关配置</p><p><strong>nginx配置</strong></p><p>cd nginx安装目录:</p><p>如果不确定nginx安装目录nginx -t可以看到the configuration…nginx.conf即配置文件所在位置，安装方法不同文件保存位置也会发生变化<br><img src="/img/content/linux/4.png" srcset="/img/loading.gif" alt=""></p><p>由此可以看出nginx配置文件在etc/nginx下面的</p><pre><code>cd /etc/nginx/</code></pre><p>备份nginx配置</p><pre><code>cp nginx.conf nginx.conf.cp</code></pre><p>编辑配置文件</p><pre><code>vim nginx.conf</code></pre><p>配置内容</p><pre><code>   &quot;&quot;&quot;&quot;   #部署需要配置的部分   server {        listen       80; #监听80端口请求        server_name  ip ;  #这里配置你的ip        location / {                proxy_pass http://127.0.0.1:8000; #将xx端口转发nginx                proxy_set_header Host $host;  #请求头                proxy_set_header X-Real-IP $remote_addr;  #将项目请求ip转发到你的ip上                }    #这段写法无需更改复制即可        #charset koi8-r;        #access_log  logs/host.access.log  main;        location /static {          alias /root/DjangoBlog/collectedstatic;  #配置静态文件位置        }&quot;&quot;&quot;&quot;</code></pre><p>配置完成保存退出</p><p>重载配置文件：</p><pre><code>nginx  -s reload</code></pre><p>至此整个项目配置完成</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django进阶——Django REST框架</title>
    <link href="/2020/02/13/Django%E8%BF%9B%E9%98%B6/"/>
    <url>/2020/02/13/Django%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="一-背景"><a href="#一-背景" class="headerlink" title="一 背景"></a>一 背景</h1><p>在使用python进行实际生产中，团队研发经常采用前后端分离的模式，因为前端现在有越来越强大的框架，后端也有很多语言可以实现接口，将前后端分离有助于技术栈的选择和配合，也能更好的让技术人员发挥长板。将前后端分离有助于技术栈的选择和配合，也能更好的让技术人员发挥长板。这里介绍Django REST framework来开发后端API。</p><h1 id="二-Django-REST-framework-简介"><a href="#二-Django-REST-framework-简介" class="headerlink" title="二 Django REST framework 简介"></a>二 Django REST framework 简介</h1><p>Django REST framework 是一套基于Django框架编写RESTful风格API的组件，用于构建Web API的功能强大且灵活的工具包。<br>卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。<br><img src="/img/content/django/django_rest.png" srcset="/img/loading.gif" alt=""></p><h2 id="2-1-Django-REST-framework-的特点："><a href="#2-1-Django-REST-framework-的特点：" class="headerlink" title="2.1 Django REST framework 的特点："></a>2.1 Django REST framework 的特点：</h2><p>a) Serializers（序列化）：简单来说就是将复杂的数据结构变成JSON或XML格式，支持ORM和非ORM数据源的序列化。</p><pre><code>Serializers allow complex data such as querysets and model instances to be converted to native Python datatypes that can then be easily rendered into JSON, XML or other content types. Serializers also provide deserialization, allowing parsed data to be converted back into complex types, after first validating the incoming data.</code></pre><p>b) Authentication（身份认证）：快速实现支持Auth1、Auth2方式的权限验证。</p><p>c) Request and Response（请求与响应）：扩展了常规的HttpResquest和TemplateResponse。</p><p>d) ViewSet and Routers（视图集和路由）：类似与Java框架的Controllers<br>……</p><h1 id="三-小试牛刀"><a href="#三-小试牛刀" class="headerlink" title="三 小试牛刀"></a>三 小试牛刀</h1><h2 id="3-1-配置环境"><a href="#3-1-配置环境" class="headerlink" title="3.1 配置环境"></a>3.1 配置环境</h2><p>Python 版本： 3.6</p><pre><code class="python">pip install djangopip install djangorestframework</code></pre><h2 id="3-2-创建项目"><a href="#3-2-创建项目" class="headerlink" title="3.2 创建项目"></a>3.2 创建项目</h2><pre><code class="python">django-admin.py startproject test_restcd test_rest</code></pre><h2 id="3-3-创建App"><a href="#3-3-创建App" class="headerlink" title="3.3 创建App"></a>3.3 创建App</h2><pre><code class="python">python manage.py startapp product</code></pre><h2 id="3-4-在-test-rest-settings-py添加App"><a href="#3-4-在-test-rest-settings-py添加App" class="headerlink" title="3.4. 在/test_rest/settings.py添加App"></a>3.4. 在/test_rest/settings.py添加App</h2><pre><code class="python">INSTALLED_APPS = (    ...    &#39;rest_framework&#39;,    &#39;product&#39;,)</code></pre><h2 id="3-5-配置-test-rest-urls-py"><a href="#3-5-配置-test-rest-urls-py" class="headerlink" title="3.5 配置 /test_rest/urls.py"></a>3.5 配置 /test_rest/urls.py</h2><pre><code class="python">from django.conf.urls import url, includeurlpatterns = [    url(r&#39;^product/&#39;, include(&#39;product.urls&#39;)),]</code></pre><h2 id="3-6-编写model层-product-model-py"><a href="#3-6-编写model层-product-model-py" class="headerlink" title="3.6 编写model层 /product/model.py"></a>3.6 编写model层 /product/model.py</h2><pre><code class="python">from django.db import modelsclass Product(models.Model):    name = models.CharField(max_length=50)    price = models.DecimalField(max_digits=8,decimal_places=2    def __str__(self):          return self.name</code></pre><h2 id="3-7-配置数据库"><a href="#3-7-配置数据库" class="headerlink" title="3.7 配置数据库"></a>3.7 配置数据库</h2><pre><code class="python">python manage.py makemigratonspython manage.py migrate</code></pre><h2 id="3-8-编写序列化模块-product-serializer-py"><a href="#3-8-编写序列化模块-product-serializer-py" class="headerlink" title="3.8 编写序列化模块 /product/serializer.py"></a>3.8 编写序列化模块 /product/serializer.py</h2><pre><code class="python">from rest_framework import serializersfrom .models import Productclass ProductSerializer(serializers.ModelSerializer):    class Meta:        model = Product        fields = (&quot;id&quot;,&quot;name&quot;,&quot;price&quot;)</code></pre><h2 id="3-9-编写视图-product-views-py"><a href="#3-9-编写视图-product-views-py" class="headerlink" title="3.9 编写视图 /product/views.py"></a>3.9 编写视图 /product/views.py</h2><pre><code class="python">from rest_framework import statusfrom rest_framework.response import Responsefrom rest_framework.views import APIViewfrom rest_framework import genericsfrom .models import Productfrom .serializers import ProductSerializer# 使用APIViewclass ProductView(APIView):    def get(self, request, format=None):        product = Product.objects.all()        serializer = ProductSerializer(product, many=True)        return Response(serializer.data)    def post(self, request, format=None):        serializer = ProductSerializer(data=request.data)        if serializer.is_valid():            serializer.save()            return Response(serializer.data, status=status.HTTP_201_CREATED)        else:            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)</code></pre><h2 id="3-10-编写路由-product-urls-py"><a href="#3-10-编写路由-product-urls-py" class="headerlink" title="3.10 编写路由 /product/urls.py"></a>3.10 编写路由 /product/urls.py</h2><pre><code class="python">from django.conf.urls import  urlfrom . import viewsurlpatterns = [    url(r&#39;^api/$&#39;, views.ProductView.as_view(), name=&#39;product&#39;),]</code></pre><h2 id="3-11-测试"><a href="#3-11-测试" class="headerlink" title="3.11 测试"></a>3.11 测试</h2><pre><code class="python">curl http://localhost:8000/product/api/curl -X POST http://localhost:8000/product/api/ -d &quot;name=iPhone8&amp;price=168.88&quot;curl http://localhost:8000/product/api/</code></pre><h1 id="四-参考资料"><a href="#四-参考资料" class="headerlink" title="四 参考资料"></a>四 参考资料</h1><h2 id="4-1-官方网站"><a href="#4-1-官方网站" class="headerlink" title="4.1 官方网站"></a>4.1 官方网站</h2><p><a href="http://www.django-rest-framework.org/" target="_blank" rel="noopener">http://www.django-rest-framework.org/</a><br><a href="https://github.com/encode/django-rest-framework/" target="_blank" rel="noopener">https://github.com/encode/django-rest-framework/</a></p><h2 id="4-2-参考文档"><a href="#4-2-参考文档" class="headerlink" title="4.2 参考文档"></a>4.2 参考文档</h2><p>Django Rest Framework–oauth实验笔记–参考官方文档<br><a href="https://blog.csdn.net/yu359697395/article/details/78918840" target="_blank" rel="noopener">https://blog.csdn.net/yu359697395/article/details/78918840</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sphinx(斯芬克斯)文档概述</title>
    <link href="/2020/02/13/Sphinx-%E6%96%AF%E8%8A%AC%E5%85%8B%E6%96%AF-%E6%96%87%E6%A1%A3%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/02/13/Sphinx-%E6%96%AF%E8%8A%AC%E5%85%8B%E6%96%AF-%E6%96%87%E6%A1%A3%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h1><p>写文档是开发人员日常工作中的一项重要内容，除了word之外，我更偏爱使用标记语言(Markup Language)。使用标记语言，可以利用简单、免费的文本编辑器(记事本，vim, emacs…）编写文档并设置格式，再生成html或pdf等格式，或者直接把编辑好的文件传到github或wiki上面 ，通过浏览器可以直接查看带有格式的文档。</p><p>目前标记语言主要有两种，Markdown和reStructuredText（简称reST)。该使用哪一种是一个见仁见智的选择，我在这里就不比较它们（包括其他标记语言）的优劣了，感兴趣的可以参考：</p><p><a href="https://www.zhihu.com/question/19851600" target="_blank" rel="noopener">知乎：Org-mode、reST、 Markdown (各有什么优缺点？)</a></p><p>很多开源项目的文档就是用sphinx+reST做的，那么该如何安装和使用呢？详见下文</p><h1 id="二-安装软件包"><a href="#二-安装软件包" class="headerlink" title="二 安装软件包"></a>二 安装软件包</h1><p>使用sphinx+reST编写文档，需要安装一些软件包</p><pre><code>sudo apt-get install python-pipsudo pip install -U Sphinx</code></pre><p>如果要从代码注释生成API文档，需要安装doxygen和breathe插件，后者可以让sphinx处理doxygen生成的xml:</p><pre><code>sudo apt-get install doxygensudo pip install breathe</code></pre><p>如果要生成pdf文件，需要安装texlive:</p><pre><code>sudo apt-get install texlive-full</code></pre><p>如果要生成中文pdf，则需要确认安装了必要的东亚语言和字体包，比如texlive-lang-cjk和texlive-fonts-recommended，可以参考<a href="http://www.tuicool.com/articles/nAJJVb" target="_blank" rel="noopener">http://www.tuicool.com/articles/nAJJVb</a> 。　　</p><h1 id="三-项目建立"><a href="#三-项目建立" class="headerlink" title="三 项目建立"></a>三 项目建立</h1><p>最简单的方法是建立工作目录后（这里是doc），在其中运行sphinx-quickstart(终端执行)。运行此命令后sphinx会问你一些问题，根据情况回答即可。在这里我建立了一个名为foo的Project，版本是1.0，作者名为zzq，将source与build目录放开，其他都选默认：</p><pre><code>sphinx-quickstart Welcome to the Sphinx 1.3.3 quickstart utility.Please enter values for the following settings (just press Enter toaccept a default value, if one is given in brackets).Enter the root path for documentation.&gt; Root path for the documentation [.]: You have two options for placing the build directory for Sphinx output.Either, you use a directory &quot;_build&quot; within the root path, or you separate&quot;source&quot; and &quot;build&quot; directories within the root path.&gt; Separate source and build directories (y/n) [n]: yInside the root directory, two more directories will be created; &quot;_templates&quot;for custom HTML templates and &quot;_static&quot; for custom stylesheets and other staticfiles. You can enter another prefix (such as &quot;.&quot;) to replace the underscore.&gt; Name prefix for templates and static dir [_]: The project name will occur in several places in the built documentation.&gt; Project name: foo&gt; Author name(s): zzqSphinx has the notion of a &quot;version&quot; and a &quot;release&quot; for thesoftware. Each version can have multiple releases. For example, forPython the version is something like 2.5 or 3.0, while the release issomething like 2.5.1 or 3.0a1.  If you don&#39;t need this dual structure,just set both to the same value.&gt; Project version: 1.0&gt; Project release [1.0]: If the documents are to be written in a language other than English,you can select a language here by its language code. Sphinx will thentranslate text that it generates into that language.For a list of supported codes, seehttp://sphinx-doc.org/config.html#confval-language.&gt; Project language [en]: The file name suffix for source files. Commonly, this is either &quot;.txt&quot;or &quot;.rst&quot;.  Only files with this suffix are considered documents.&gt; Source file suffix [.rst]: One document is special in that it is considered the top node of the&quot;contents tree&quot;, that is, it is the root of the hierarchical structureof the documents. Normally, this is &quot;index&quot;, but if your &quot;index&quot;document is a custom template, you can also set this to another filename.&gt; Name of your master document (without suffix) [index]: Sphinx can also add configuration for epub output:&gt; Do you want to use the epub builder (y/n) [n]: Please indicate if you want to use one of the following Sphinx extensions:&gt; autodoc: automatically insert docstrings from modules (y/n) [n]: &gt; doctest: automatically test code snippets in doctest blocks (y/n) [n]: &gt; intersphinx: link between Sphinx documentation of different projects (y/n) [n]: &gt; todo: write &quot;todo&quot; entries that can be shown or hidden on build (y/n) [n]: &gt; coverage: checks for documentation coverage (y/n) [n]: &gt; pngmath: include math, rendered as PNG images (y/n) [n]: &gt; mathjax: include math, rendered in the browser by MathJax (y/n) [n]: &gt; ifconfig: conditional inclusion of content based on config values (y/n) [n]: &gt; viewcode: include links to the source code of documented Python objects (y/n) [n]: A Makefile and a Windows command file can be generated for you so that youonly have to run e.g. `make html&#39; instead of invoking sphinx-builddirectly.&gt; Create Makefile? (y/n) [y]: &gt; Create Windows command file? (y/n) [y]: Creating file ./source/conf.py.Creating file ./source/index.rst.Creating file ./Makefile.Creating file ./make.bat.Finished: An initial directory structure has been created.You should now populate your master file ./source/index.rst and create other documentationsource files. Use the Makefile to build the docs, like so:   make builderwhere &quot;builder&quot; is one of the supported builders, e.g. html, latex or linkcheck.~/doc$ </code></pre><p>执行完以上命令上doc目录中有以下内容（根据执行sphinx-quickstart命令时对各问题的回答不同，下文的文件内容和文件名可能有所不同）：</p><pre><code>build  make.bat  Makefile  source</code></pre><p>其中source和build分别是源文件和编译生成文件的存放目录，Makefile和make.bat分别是Linux和Windows下的makefile。</p><p>source目录下有以下内容：</p><pre><code>conf.py  index.rst  _static  _templates</code></pre><p>其中conf.py是配置文件，index.rst是主框架文件，_static是静态文件存放目录，比如可以放一些图片什么的，_templates是模板存放目录。</p><p>我们先创建2个文件intro.rst和sample.rst，在里面只写标题。这两个文件的内容分别是<br>intro.rst:</p><pre><code>intro=====</code></pre><p>sample.rst:</p><pre><code>sample======</code></pre><p>然后编辑index.rst，在toctree指导语句（directive）中加入刚才两个文件的文件名，后缀省略，路径是相对于源目录source的：</p><pre><code>Welcome to foo&#39;s documentation!                                    ===============================                                    Contents:                                                          .. toctree::                                                          :maxdepth: 2                                                       intro                                                              sample                                                          </code></pre><p>此时，可以回到source的上一级目录（有Makefile的目录），运行make html，即可在build目录中生成HTML文件：</p><pre><code>~/doc/source$ cd ..~/doc$ make htmlsphinx-build -b html -d build/doctrees   source build/htmlRunning Sphinx v1.3.3loading pickled environment... donebuilding [mo]: targets for 0 po files that are out of datebuilding [html]: targets for 2 source files that are out of dateupdating environment: 0 added, 2 changed, 0 removedreading sources... [100%] sample                                                                                      looking for now-outdated files... none foundpickling environment... donechecking consistency... donepreparing documents... donewriting output... [100%] sample                                                                                       generating indices... genindexwriting additional pages... searchcopying static files... donecopying extra files... donedumping search index in English (code: en) ... donedumping object inventory... donebuild succeeded.Build finished. The HTML pages are in build/html.</code></pre><p>编译成功后使用浏览器打开build/html目录下的index.html，是这样的：</p><p><img src="/img/content/sphinx/1.png" srcset="/img/loading.gif" alt=""></p><p>到此，一次典型的环境配置与html生成步骤就完成了。</p><p>如果觉得生成的html主题风格自己不喜欢，可以个性source/conf.py，找到</p><pre><code># The theme to use for HTML and HTML Help pages.  See the documentation for# a list of builtin themes.                                     html_theme = &#39;alabaster&#39;</code></pre><p>把alabaster改成其他主题名就好了 。内置的主题有不少，见：<a href="http://sphinx-doc.org/theming.html#builtin-themes" target="_blank" rel="noopener">http://sphinx-doc.org/theming.html#builtin-themes</a></p><h1 id="四-conf-py配置"><a href="#四-conf-py配置" class="headerlink" title="四 conf.py配置"></a>四 conf.py配置</h1><h2 id="4-1-主题样式"><a href="#4-1-主题样式" class="headerlink" title="4.1 主题样式"></a>4.1 主题样式</h2><p>设置alabaster主题只需在html_theme中设置名字即可:</p><p>html_theme = ‘alabaster’<br>而要设置更美观的sphinx_rtd_theme主题，需要在文件头部加上:</p><p>import sphinx_rtd_theme<br>再设置html_theme:</p><p>html_theme = ‘sphinx_rtd_theme’</p><h2 id="4-2-LOGO"><a href="#4-2-LOGO" class="headerlink" title="4.2 LOGO"></a>4.2 LOGO</h2><p>在html_logo中设置图片文件路径:</p><p>html_logo = ‘./logo.png’</p><h2 id="4-3-不显示源文件链接"><a href="#4-3-不显示源文件链接" class="headerlink" title="4.3 不显示源文件链接"></a>4.3 不显示源文件链接</h2><p>默认会在生成的html页中显示rst源文件链接，做如下设置后不显示:</p><p>html_show_sourcelink = False</p><h1 id="五-Index页配置"><a href="#五-Index页配置" class="headerlink" title="五 Index页配置"></a>五 Index页配置</h1><p>主要是设置目录树:</p><pre><code>.. toctree::    :maxdepth: 3    :numbered:    foo    bar</code></pre><p>maxdepth把index.html页中目录的标题显示深度限制设为3，numbered为编号。之后空一行，在下面列出各子文档，可以不加文件后缀。</p><p>注意：这里同样要注意代码对齐。</p><h1 id="六-生成API文档"><a href="#六-生成API文档" class="headerlink" title="六 生成API文档"></a>六 生成API文档</h1><p>可以配合使用sphinx+reST+breathe+doxygen来给代码生成API文档并无缝添加到已有的文档结构中。</p><h2 id="6-1-Step1"><a href="#6-1-Step1" class="headerlink" title="6.1 Step1"></a>6.1 Step1</h2><p>运行:</p><p>doxygen -g<br>生成doxygen配置文件(默认文件名是Doxyfile)，然后修改此文件：</p><ul><li>项目名称 PROJECT_NAME = “MyProject”</li><li>对C项目优化 OPTIMIZE_OUTPUT_FOR_C = YES</li><li>源文件路径 INPUT = /home/tom/project/include</li><li>源文件编码 INPUT_ENCODEING = UTF-8</li><li>生成XML GENERATE_XML = YES 因为要使用breathe扩展，所以必须生成xml</li><li>XML输出目录 XML_OUTPUT = my_xml</li><li>不需要生成html GENERATE_HTML = NO</li><li>不需要生成latex GENERATE_LATEX = NO</li><li>不显示包含文件 SHOW_INCLUDE_FILES = NO</li></ul><h2 id="6-2-Step2"><a href="#6-2-Step2" class="headerlink" title="6.2 Step2"></a>6.2 Step2</h2><p>运行:</p><p>doxygen [Doxyfile]<br>输出注释，主要是xml。</p><h2 id="6-3-Step3"><a href="#6-3-Step3" class="headerlink" title="6.3 Step3"></a>6.3 Step3</h2><p>配置conf.py，以支持breathe扩展。前提是这一扩展已经安装。</p><p>加入扩展:</p><p>extensions = [‘breathe’]<br>配置breathe:</p><pre><code>breathe_projects = { &quot;myproject&quot;: &quot;./my_xml&quot; }breathe_default_project = &quot;myproject&quot;breathe_domain_by_extension = {&quot;h&quot; : &quot;c&quot;}</code></pre><h2 id="6-4-Step4"><a href="#6-4-Step4" class="headerlink" title="6.4 Step4"></a>6.4 Step4</h2><p>按breathe扩展语法编写rst文件，比如:</p><pre><code>My API==========sp.h----.. doxygenfile:: sp.h</code></pre><p>上面的语句为项目中的sp.h接口文件生成了html文档。</p><p>最后，运行 make html 生成html即可。</p><p>在这些步骤中，需要先调用doxygen生成xml，再调用sphinx-build(make html时自动调用)生成最终文档，如果想一步完成，可以在Makefile中加入doxygen调用:</p><pre><code>html:    doxygen Doxyfile    $(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html    @echo    @echo &quot;Build finished. The HTML pages are in $(BUILDDIR)/html.&quot;</code></pre><h1 id="七-生成PDF"><a href="#七-生成PDF" class="headerlink" title="七 生成PDF"></a>七 生成PDF</h1><p>生成PDF的前提是安装了texlive，如果要生成中文PDF，还需要确认安装了东亚语言包和字体包(texlive-lang-cjk, texlive-fonts-recommands之类）。</p><p>然后配置conf.py，在latex_elements中加入:</p><pre><code>latex_elements = {# The paper size (&#39;letterpaper&#39; or &#39;a4paper&#39;).#&#39;papersize&#39;: &#39;letterpaper&#39;,# The font size (&#39;10pt&#39;, &#39;11pt&#39; or &#39;12pt&#39;).#&#39;pointsize&#39;: &#39;10pt&#39;,# Additional stuff for the LaTeX preamble.&#39;preamble&#39;: &#39;&#39;&#39;\\hypersetup{unicode=true}\\usepackage{CJKutf8}\\AtBeginDocument{\\begin{CJK}{UTF8}{gbsn}}\\AtEndDocument{\\end{CJK}}&#39;&#39;&#39;,</code></pre><p>最后运行 make latexpdf 即可。</p><h1 id="八-reST语法介绍"><a href="#八-reST语法介绍" class="headerlink" title="八 reST语法介绍"></a>八 reST语法介绍</h1><p>reStructuredText标记语言比Makedown强大很多，支持多种排版样式。不过这里只介绍开发人员主要会用到的一些样式。reST文档的详细介绍见<a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="noopener">http://docutils.sourceforge.net/rst.html</a></p><h1 id="九-参考"><a href="#九-参考" class="headerlink" title="九 参考"></a>九 参考</h1><p><a href="https://www.sphinx-doc.org/en/master/" target="_blank" rel="noopener">sphinx-doc官网</a><br><a href="https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html" target="_blank" rel="noopener">reStructuredText标记规范</a><br>转文： <a href="https://www.cnblogs.com/zzqcn/p/5096876.html" target="_blank" rel="noopener">https://www.cnblogs.com/zzqcn/p/5096876.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>sphinx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim 命令、操作、快捷键介绍</title>
    <link href="/2020/02/13/Vim%E5%91%BD%E4%BB%A4%E3%80%81%E6%93%8D%E4%BD%9C%E3%80%81%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/02/13/Vim%E5%91%BD%E4%BB%A4%E3%80%81%E6%93%8D%E4%BD%9C%E3%80%81%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h2><p>以:和/开头的命令都有历史纪录，可以首先键入:或/然后按上下箭头来选择某个历史命令。</p><h2 id="启动vim"><a href="#启动vim" class="headerlink" title="启动vim"></a>启动vim</h2><p>在命令行窗口中输入以下命令即可</p><p>vim 直接启动vim</p><p>vim filename 打开vim并创建名为filename的文件</p><h2 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h2><p>打开单个文件</p><p>vim file</p><p>同时打开多个文件</p><p>vim file1 file2 file3 …</p><p>在vim窗口中打开一个新文件</p><p>:open file</p><p>在新窗口中打开文件</p><p>:split file</p><p>切换到下一个文件</p><p>:bn</p><p>切换到上一个文件</p><p>:bp</p><p>查看当前打开的文件列表，当前正在编辑的文件会用[]括起来。</p><p>:args</p><p>打开远程文件，比如ftp或者share folder</p><p>:e <a href="ftp://192.168.10.76/abc.txt" target="_blank" rel="noopener">ftp://192.168.10.76/abc.txt</a></p><p>:e \qadrive\test\1.txt</p><h2 id="vim的模式"><a href="#vim的模式" class="headerlink" title="vim的模式"></a>vim的模式</h2><p>正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空<br>插入模式（按i键进入） 左下角显示–INSERT–<br>可视模式（不知道如何进入） 左下角显示–VISUAL–</p><h2 id="导航命令"><a href="#导航命令" class="headerlink" title="导航命令"></a>导航命令</h2><p>% 括号匹配</p><h2 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h2><p>i 在当前位置生前插入</p><p>I 在当前行首插入</p><p>a 在当前位置后插入</p><p>A 在当前行尾插入</p><p>o 在当前行之后插入一行</p><p>O 在当前行之前插入一行</p><h2 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h2><p>/text　　查找text，按n健查找下一个，按N健查找前一个。</p><p>?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。</p><p>vim中有一些特殊字符在查找时需要转义　　.*[]^%/?~$</p><p>:set ignorecase　　忽略大小写的查找</p><p>:set noignorecase　　不忽略大小写的查找</p><p>查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。</p><p>:set hlsearch　　高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。</p><p>:set nohlsearch　　关闭高亮搜索显示</p><p>:nohlsearch　　关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。</p><p>:set incsearch　　逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。</p><p>:set wrapscan　　重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。</p><h2 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h2><p>ra 将当前字符替换为a，当期字符即光标所在字符。</p><p>s/old/new/ 用old替换new，替换当前行的第一个匹配</p><p>s/old/new/g 用old替换new，替换当前行的所有匹配</p><p>%s/old/new/ 用old替换new，替换所有行的第一个匹配</p><p>%s/old/new/g 用old替换new，替换整个文件的所有匹配</p><p>:10,20 s/^/ /g 在第10行知第20行每行前面加四个空格，用于缩进。</p><p>ddp 交换光标所在行和其下紧邻的一行。</p><h2 id="移动命令"><a href="#移动命令" class="headerlink" title="移动命令"></a>移动命令</h2><p>h 左移一个字符<br>l 右移一个字符，这个命令很少用，一般用w代替。<br>k 上移一个字符<br>j 下移一个字符<br>以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！<esc>，这里的Esc是必须的，否则命令不生效。</esc></p><p>w 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。</p><p>b 向后移动一个单词 2b 向后移动2个单词</p><p>e，同w，只不过是光标停在单词尾部</p><p>ge，同b，光标停在单词尾部。</p><p>^ 移动到本行第一个非空白字符上。</p><p>0（数字0）移动到本行第一个字符上，</p><p><home>移动到本行第一个字符。同0健。</home></p><p>$ 移动到行尾 3$ 移动到下面3行的行尾</p><p>gg 移动到文件头。 = [[</p><p>G（shift + g） 移动到文件尾。 = ]]</p><p>f（find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。</p><p>F 同f，反向查找。</p><p>跳到指定行，冒号+行号，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行。</p><p>Ctrl + e 向下滚动一行</p><p>Ctrl + y 向上滚动一行</p><p>Ctrl + d 向下滚动半屏</p><p>Ctrl + u 向上滚动半屏</p><p>Ctrl + f 向下滚动一屏</p><p>Ctrl + b 向上滚动一屏</p><h2 id="撤销和重做"><a href="#撤销和重做" class="headerlink" title="撤销和重做"></a>撤销和重做</h2><p>u 撤销（Undo）<br>U 撤销对整行的操作<br>Ctrl + r 重做（Redo），即撤销的撤销。</p><h2 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h2><p>x 删除当前字符</p><p>3x 删除当前光标开始向后三个字符</p><p>X 删除当前字符的前一个字符。X=dh</p><p>dl 删除当前字符， dl=x</p><p>dh 删除前一个字符</p><p>dd 删除当前行</p><p>dj 删除上一行</p><p>dk 删除下一行</p><p>10d 删除当前行开始的10行。</p><p>D 删除当前字符至行尾。D=d$</p><p>d$ 删除当前字符之后的所有字符（本行）</p><p>kdgg 删除当前行之前所有行（不包括当前行）</p><p>jdG（jd shift + g） 删除当前行之后所有行（不包括当前行）</p><p>:1,10d 删除1-10行</p><p>:11,$d 删除11行及以后所有的行</p><p>:1,$d 删除所有行</p><p>J(shift + j)　　删除两行之间的空行，实际上是合并两行。</p><h2 id="拷贝和粘贴"><a href="#拷贝和粘贴" class="headerlink" title="拷贝和粘贴"></a>拷贝和粘贴</h2><p>yy 拷贝当前行</p><p>nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。</p><p>p 在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。</p><p>shift+p 在当前行前粘贴</p><p>:1,10 co 20 将1-10行插入到第20行之后。</p><p>:1,$ co $ 将整个文件复制一份并添加到文件尾部。</p><p>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制</p><p>ddp交换当前行和其下一行</p><p>xp交换当前字符和其后一个字符</p><h2 id="剪切命令"><a href="#剪切命令" class="headerlink" title="剪切命令"></a>剪切命令</h2><p>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切</p><p>ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴</p><p>:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。</p><p>:1, 10 m 20 将第1-10行移动到第20行之后。</p><h2 id="退出命令"><a href="#退出命令" class="headerlink" title="退出命令"></a>退出命令</h2><p>:wq 保存并退出</p><p>ZZ 保存并退出</p><p>:q! 强制退出并忽略所有更改</p><p>:e! 放弃所有修改，并打开原来文件。</p><h2 id="窗口命令"><a href="#窗口命令" class="headerlink" title="窗口命令"></a>窗口命令</h2><p>:split或new 打开一个新窗口，光标停在顶层的窗口上</p><p>:split file或:new file 用新窗口打开文件</p><p>split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。</p><p>Ctrl+ww 移动到下一个窗口</p><p>Ctrl+wj 移动到下方的窗口</p><p>Ctrl+wk 移动到上方的窗口</p><p>关闭窗口</p><p>:close 最后一个窗口不能使用此命令，可以防止意外退出vim。</p><p>:q 如果是最后一个被关闭的窗口，那么将退出vim。</p><p>ZZ 保存并退出。</p><p>关闭所有窗口，只保留当前窗口</p><p>:only</p><p>录制宏</p><p>按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。</p><h2 id="执行shell命令"><a href="#执行shell命令" class="headerlink" title="执行shell命令"></a>执行shell命令</h2><p>:!command</p><p>:!ls 列出当前目录下文件</p><p>:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。</p><p>:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。</p><p>:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。</p><h2 id="注释命令"><a href="#注释命令" class="headerlink" title="注释命令"></a>注释命令</h2><p>perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#</p><p>3,5 s/^/#/g 注释第3-5行</p><p>3,5 s/^#//g 解除3-5行的注释</p><p>1,$ s/^/#/g 注释整个文档。</p><p>:%s/^/#/g 注释整个文档，此法更快。</p><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><p>:help or F1 显示整个帮助<br>:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。<br>:help ‘number’ Vim选项的帮助用单引号括起<br>:help<esc>特殊键的帮助用&lt;&gt;扩起<br>:help -t Vim启动参数的帮助用-<br>：help i_<esc>插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式<br>帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回</esc></esc></p><h2 id="其他非编辑命令"><a href="#其他非编辑命令" class="headerlink" title="其他非编辑命令"></a>其他非编辑命令</h2><p>. 重复前一次命令</p><p>:set ruler?　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看</p><p>:scriptnames　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。</p><p>:set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。</p><h2 id="Vim教程"><a href="#Vim教程" class="headerlink" title="Vim教程"></a>Vim教程</h2><p>在Unix系统上<br>$ vimtutor<br>在Windows系统上<br>:help tutor<br>:syntax 列出已经定义的语法项<br>:syntax clear 清除已定义的语法规则<br>:syntax case match 大小写敏感，int和Int将视为不同的语法元素<br>:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</p>]]></content>
    
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用python操作excel表格</title>
    <link href="/2020/02/13/%E4%BD%BF%E7%94%A8python%E6%93%8D%E4%BD%9Cexcel%E8%A1%A8%E6%A0%BC/"/>
    <url>/2020/02/13/%E4%BD%BF%E7%94%A8python%E6%93%8D%E4%BD%9Cexcel%E8%A1%A8%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="一-python中与excel操作相关的模块"><a href="#一-python中与excel操作相关的模块" class="headerlink" title="一 python中与excel操作相关的模块"></a>一 python中与excel操作相关的模块</h1><blockquote><p>xlrd库：从excel中读取数据，支持xls、xlsx<br>xlwt库：对excel进行修改操作，不支持对xlsx格式的修改<br>xlutils库：在xlw和xlrd中，对一个已存在的文件进行修改。<br>openpyxl：主要针对xlsx格式的excel进行读取和编辑。</p></blockquote><p><strong>这里介绍openxl相关语法</strong><br>官方介绍： <a href="https://openpyxl.readthedocs.io/en/stable/" target="_blank" rel="noopener">https://openpyxl.readthedocs.io/en/stable/</a><br>安装方式：pip install openpyxl</p><p>Excel中的三大对象:</p><ul><li>WorkBook：工作簿对象</li><li>Sheet：表单对象</li><li>Cell：表格对象</li></ul><h1 id="二-openpyxl对Excel的操作"><a href="#二-openpyxl对Excel的操作" class="headerlink" title="二 openpyxl对Excel的操作"></a>二 openpyxl对Excel的操作</h1><ul><li>创建一个工作薄：wb = openpyxl.Workbook()</li><li>新增一个sheet表单：wb.create_sheet(‘test_case’)</li><li>保存case.xlsx文件：wb.save(‘cases.xlsx’)</li><li>打开工作簿：wb = openpyxl.load_workbook(‘cases.xlsx’)</li><li>选取表单：sh = wb[‘Sheet1’</li><li>读取第一行、第一列的数据：ce = sh.cell(row = 1,column = 1)</li><li>按行读取数据：row_data = list(sh.rows)</li><li>关闭工作薄：wb.close()</li><li>按列读取数据：columns_data = list(sh.columns)</li><li>写入数据之前，该文件一定要处于关闭状态</li><li>写入第一行、第四列的数据 value = ‘result’：sh.cell(row = 1,column = 4,value = ‘result’)</li><li>获取最大行总数、最大列总数：sh.max_row、sh.max_column</li><li>del 删除表单的用法：del wb[‘sheet_name’]</li><li>remove 删除表单的用法：sh = wb[‘sheet_name’] wb.remove(sh)</li></ul><pre><code class="python">import openpyxl# 创建一个工作簿wb = openpyxl.Workbook()# 创建一个test_case的sheet表单wb.create_sheet(&#39;test_case&#39;)# 保存为一个xlsx格式的文件wb.save(&#39;cases.xlsx&#39;)# 读取excel中的数据# 第一步：打开工作簿wb = openpyxl.load_workbook(&#39;cases.xlsx&#39;)# 第二步：选取表单sh = wb[&#39;Sheet1&#39;]# 第三步：读取数据# 参数 row:行  column：列ce = sh.cell(row = 1,column = 1)   # 读取第一行，第一列的数据print(ce.value)# 按行读取数据 list(sh.rows)print(list(sh.rows)[1:])     # 按行读取数据，去掉第一行的表头信息数据for cases in list(sh.rows)[1:]:    case_id =  cases[0].value    case_excepted = cases[1].value    case_data = cases[2].value    print(case_excepted,case_data)# 关闭工作薄wb.close()</code></pre><h1 id="三-封装一个读取用例的excel类：用来实现读取数据和写入数据的功能"><a href="#三-封装一个读取用例的excel类：用来实现读取数据和写入数据的功能" class="headerlink" title="三 封装一个读取用例的excel类：用来实现读取数据和写入数据的功能"></a>三 封装一个读取用例的excel类：用来实现读取数据和写入数据的功能</h1><p>cases.xlsx的测试数据：</p><h2 id="3-1-按行读取数据，存储在列表中"><a href="#3-1-按行读取数据，存储在列表中" class="headerlink" title="3.1 按行读取数据，存储在列表中"></a>3.1 按行读取数据，存储在列表中</h2><pre><code class="python">import openpyxlclass Case: #这个类用来存储用例的    __slots__ = [] #特殊的类属性，可以用来限制这个类创建的实例属性添加 可写可不写    passclass ReadExcel(object): #读取excel数据的类    def __init__(self,file_name,sheet_name):        &quot;&quot;&quot;        这个是用来初始化读取对象的        :param file_name: 文件名 ---&gt; str类型        :param sheet_name: 表单名 ———&gt; str类型        &quot;&quot;&quot;        # 打开文件        self.wb = openpyxl.load_workbook(file_name)        # 选择表单        self.sh = self.wb[sheet_name]    def read_data_line(self):        #按行读取数据转化为列表        rows_data = list(self.sh.rows)        # print(rows_data)        # 获取表单的表头信息        titles = []        for title in rows_data[0]:            titles.append(title.value)        # print(titles)        #定义一个空列表用来存储测试用例        cases = []        for case in rows_data[1:]:            # print(case)            data = []            for cell in case: #获取一条测试用例数据                # print(cell.value)                data.append(cell.value)                # print(data)                #判断该单元格是否为字符串，如果是字符串类型则需要使用eval();如果不是字符串类型则不需要使用eval()                if isinstance(cell.value,str):                    data.append(eval(cell.value))                else:                    data.append(cell.value)                #将该条数据存放至cases中            # print(dict(list(zip(titles,data))))                case_data = dict(list(zip(titles,data)))                cases.append(case_data)        return casesif __name__ == &#39;__main__&#39;:    r = ReadExcel(&#39;cases.xlsx&#39;,&#39;Sheet1&#39;)    data1 = r.read_data_line()    print(data1)</code></pre><h2 id="3-2-按行读取数据，存储在对象中"><a href="#3-2-按行读取数据，存储在对象中" class="headerlink" title="3.2 按行读取数据，存储在对象中"></a>3.2 按行读取数据，存储在对象中</h2><pre><code class="python">import openpyxlclass Case:    passclass ReadExcel(object):    def __init__(self,filename,sheetname):        self.wb = openpyxl.load_workbook(filename)        self.sh = self.wb[sheetname]    def read_data_obj(self):        &quot;&quot;&quot;        按行读取数据  每条用例存储在一个对象中        :return:        &quot;&quot;&quot;        rows_data = list(self.sh.rows)        # print(rows_data)        # 获取表单的表头信息        titles = []        for title in rows_data[0]:            titles.append(title.value)        # print(titles)        # 定义一个空列表用来存储测试用例        cases = []        for case in rows_data[1:]:            # print(case)            #创建一个Case类的对象，用来保存用例数据            case_obj = Case()            data = []            for cell in case:  # 获取一条测试用例数据                # print(cell.value)                # data.append(cell.value)                # print(data)                if isinstance(cell.value,str):  # 判断该单元格是否为字符串，如果是字符串类型则需要使用eval();如果不是字符串类型则不需要使用eval()                    data.append(eval(cell.value))                else:                    data.append(cell.value)            # 将该条数据存放至cases中            # print(dict(list(zip(titles,data))))            case_data = list(zip(titles, data))            # print(case_data)            for i in case_data:                setattr(case_obj,i[0],i[1])            # print(case_obj)            # print(case_obj.case_id,case_obj.data,case_obj.excepted)            cases.append(case_obj)        return casesif  __name__ == &#39;__main__&#39;:    r = ReadExcel(&#39;cases.xlsx&#39;,&#39;Sheet1&#39;)    res = r.read_data_obj()    for i in res:        print(i.caseid, i.excepted, i.data)</code></pre><h2 id="3-3-将测试用例封装到列表中，读取指定列的数据"><a href="#3-3-将测试用例封装到列表中，读取指定列的数据" class="headerlink" title="3.3 将测试用例封装到列表中，读取指定列的数据"></a>3.3 将测试用例封装到列表中，读取指定列的数据</h2><pre><code class="python">import openpyxlclass Case:    passclass ReadExcelZy(object):    def __init__(self,filename,sheetname):        self.wb = openpyxl.load_workbook(filename)        self.sheet = self.wb[sheetname]        # list1 参数为一个列表，传入的是指定读取数据的列,比如[1,2,3]        # 每一行[1,3,5]列的数据，读取出来就作为一条测试用例，放在字典中        # 所有的用例放在列表中并且进行返回    def read_data(self,list1):        &quot;&quot;&quot;        :param list1:  list---&gt;要读取列   list类型        :return:    返回一个列表，每一个元素为一个用例（用例为dict类型）        &quot;&quot;&quot;        # 获取最大的行数        max_r = self.sheet.max_row        cases = []   #定义一个空列表，用来存放所有的用例数据        titles = []   #定义一个空列表，用来存放表头        # 遍历所有的行数据        for row in range(1,max_r+1):            if row != 1:      #判断是否是第一行                case_data = [] #定义一个空列表，用来存放该行的用例数据                for column in list1:                    info = self.sheet.cell(row,column).value                    # print(info)                    case_data.append(info)                    # print(list(zip(titles,case_data)))                case = dict(zip(titles,case_data))  #将该条数据和表头进行打包组合,作用相当于dict(list(zip(titles,case_data)))                # print(case)                cases.append(case)                # print(cases)            else:   #获取表头数据                for column in list1:                    title = self.sheet.cell(row,column).value                    titles.append(title)                # print(titles)        return casesif __name__ == &#39;__main__&#39;:    r = ReadExcelZy(&quot;cases.xlsx&quot;,&quot;Sheet1&quot;)    res = r.read_data([1,2,3])    for o in res:        print(o[&#39;caseid&#39;],o[&#39;data&#39;],o[&#39;excepted&#39;])</code></pre><h2 id="3-4-将测试用例封装到对象中，读取指定列的数据"><a href="#3-4-将测试用例封装到对象中，读取指定列的数据" class="headerlink" title="3.4 将测试用例封装到对象中，读取指定列的数据"></a>3.4 将测试用例封装到对象中，读取指定列的数据</h2><pre><code class="python">import openpyxlclass Case:    passclass ReadExcelZy(object):    def __init__(self,filename,sheetname):        self.wb = openpyxl.load_workbook(filename)        self.sheet = self.wb[sheetname]        # list1 参数为一个列表，传入的是指定读取数据的列,比如[1,2,3]        # 每一行[1,3,5]列的数据，读取出来就作为一条测试用例，放在字典中        # 所有的用例放在对象中并且进行返回    def read_data_obj(self,list2):        max_r1 = self.sheet.max_row      #获取最大行数        cases = []        titles = []      #用来存放表头数据        for row in range(1,max_r1+1):            if row != 1:                case_data = []                for column in list2:                    info = self.sheet.cell(row,column).value                    # print(info)                    case_data.append(info)                cases_data = list(zip(titles,case_data))                #将一条用例存到一个对象中（每一列对应对象的一个属性）                case_obj = Case()                for i in cases_data:                    # print(i)                    setattr(case_obj,i[0],i[1])                # print(case_obj.caseid,case_obj.excepted,case_obj.data)                cases.append(case_obj)            else:                for column in list2:                    title = self.sheet.cell(row,column).value                    titles.append(title)        return casesif __name__ == &#39;__main__&#39;:    r = ReadExcelZy(&quot;cases.xlsx&quot;,&quot;Sheet1&quot;)    res = r.read_data_obj([1,2,3])    for i in res:        print(i.caseid,i.data,i.excepted)</code></pre><h2 id="3-5-优化第4部分代码，将设置对象属性写在初始化方法中-封装Excel类读取数据最常用的方法"><a href="#3-5-优化第4部分代码，将设置对象属性写在初始化方法中-封装Excel类读取数据最常用的方法" class="headerlink" title="3.5 优化第4部分代码，将设置对象属性写在初始化方法中(封装Excel类读取数据最常用的方法)"></a>3.5 优化第4部分代码，将设置对象属性写在初始化方法中(封装Excel类读取数据最常用的方法)</h2><pre><code class="python">import openpyxlclass Case:  # 这个类用来存储用例的    def __init__(self, attrs):        &quot;&quot;&quot;        初始化用例        :param attrs:zip类型——&gt;[{key,value},(key1,value1)......]        &quot;&quot;&quot;        for i in attrs:            setattr(self, i[0], i[1])class ReadExcel(object):    def __init__(self, filename, sheetname):        &quot;&quot;&quot;        定义需要打开的文件及表名        :param filename:   文件名        :param sheetname:  表名        &quot;&quot;&quot;        self.wb = openpyxl.load_workbook(filename)        self.sheet = self.wb[sheetname]    def read_data_obj_new(self, list2):        # 获取最大行数        max_r1 = self.sheet.max_row        cases = []        # 用来存放表头数据        titles = []        for row in range(1, max_r1 + 1):            if row != 1:                case_data = []                for column in list2:                    info = self.sheet.cell(row, column).value                    # print(info)                    case_data.append(info)                case = list(zip(titles, case_data))                # 新建对象时，将对象传给Case类                case_obj = Case(case)                # print(case_obj.caseid,case_obj.excepted,case_obj.data)                cases.append(case_obj)            else:                # 获取表头                for column in list2:                    title = self.sheet.cell(row, column).value                    titles.append(title)                if None in titles:                    raise ValueError(&quot;传入的表头的数据有显示为空&quot;)        return casesif __name__ == &#39;__main__&#39;:    r = ReadExcel(&#39;cases.xlsx&#39;, &#39;Sheet1&#39;)    res1 = r.read_data_obj_new([1, 2, 3])    for i in res1:        print(i.caseid, i.data, i.excepted)</code></pre><h1 id="四-完整流程的代码"><a href="#四-完整流程的代码" class="headerlink" title="四 完整流程的代码"></a>四 完整流程的代码</h1><h2 id="4-1-将测试数据参数化"><a href="#4-1-将测试数据参数化" class="headerlink" title="4.1 将测试数据参数化"></a>4.1 将测试数据参数化</h2><pre><code class="python">import unittestfrom python.register_new.register import registerfrom python.register_new.register_testcase_new import RegisterTestCasefrom HTMLTestRunnerNew import HTMLTestRunnerclass RegisterTestCase(unittest.TestCase):    # 初始化测试用例    def __init__(self,modethod_name,excepted,data):         # modethod_name 测试用例方法名        super().__init__(modethod_name)        # excepted 测试用例的预期结果        self.excepted = excepted        # data 测试用例参数值                        self.data = data    def setUp(self):        print(&quot;准备测试环境，执行测试用例之前会执行此操作&quot;)    def tearDown(self):        print(&quot;还原测试环境，执行完测试用例之后会执行此操作&quot;)    def test_register(self):        res = register(*self.data)        try:            self.assertEquals(self.excepted,res)        except AssertionError as e:            print(&quot;该条测试用例执行未通通过&quot;)            raise e        else:            print(&quot;该条测试用例执行通过&quot;)  # 创建测试套件suite = unittest.TestSuite()# 将测试用例添加至测试套件中case = [{&#39;excepted&#39;:&#39;{&quot;code&quot;: 1, &quot;msg&quot;: &quot;注册成功&quot;}&#39;,&#39;data&#39;:&#39;(&#39;python1&#39;, &#39;123456&#39;,&#39;123456&#39;)&#39;},        {&#39;excepted&#39;:&#39;{&quot;code&quot;: 0, &quot;msg&quot;: &quot;两次密码不一致&quot;}&#39;,&#39;data&#39;:&#39;(&#39;python1&#39;, &#39;1234567&#39;,&#39;123456&#39;)&#39;}]for case in cases:    suite.addTest(RegisterTestCase(&#39;test_register&#39;,case[&#39;excepted&#39;],case[&#39;data&#39;]))# 执行测试套件，生成测试报告with open(&quot;report.html&quot;,&#39;wb&#39;) as f:    runner = HTMLTestRunner(        stream = f,        verbosity = 2,        title = &#39;python_test_report&#39;,        description = &#39;这是一份测试报告&#39;,        tester = &#39;WL&#39;    )    runner.run(suite)</code></pre><h2 id="4-2-将调用封装好的Excel类的完整代码流程"><a href="#4-2-将调用封装好的Excel类的完整代码流程" class="headerlink" title="4.2 将调用封装好的Excel类的完整代码流程"></a>4.2 将调用封装好的Excel类的完整代码流程</h2><pre><code class="python">import unittestfrom python.register_new.register import registerfrom python.register_new.register_testcase_new import RegisterTestCasefrom HTMLTestRunnerNew import HTMLTestRunnerfrom python.readexcel import ReadExcelclass RegisterTestCase(unittest.TestCase):    # 初始化测试用例    def __init__(self, modethod_name, excepted, data):        # modethod_name 测试用例方法名        super().__init__(modethod_name)        # excepted 测试用例的预期结果        self.excepted = excepted        # data 测试用例参数值        self.data = data    def setUp(self):        print(&quot;准备测试环境，执行测试用例之前会执行此操作&quot;)    def tearDown(self):        print(&quot;还原测试环境，执行完测试用例之后会执行此操作&quot;)    def test_register(self):        res = register(*self.data)        try:            self.assertEquals(self.excepted, res)        except AssertionError as e:            print(&quot;该条测试用例执行未通通过&quot;)            raise e        else:            print(&quot;该条测试用例执行通过&quot;)# 创建测试套件suite = unittest.TestSuite()# 调用封装好的读取数据的Excel类，获取测试数据r1 = ReadExcel(&#39;cases.xlsx&#39;, &#39;Sheet1&#39;)cases = r1.read_data_obj_new([2, 3])# 将测试用例添加至测试套件中for case in cases:    # 需要使用eva()函数对except和data进行自动识别    suite.addTest(RegisterTestCase(&#39;test_register&#39;, eval(case.excepted), eval(case.data)))# 执行测试套件，生成测试报告with open(&quot;report.html&quot;, &#39;wb&#39;) as f:    runner = HTMLTestRunner(        stream=f,        verbosity=2,        title=&#39;python_test_report&#39;,        description=&#39;这是一份测试报告&#39;,        tester=&#39;WL&#39;)    runner.run(suite)</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python进阶</title>
    <link href="/2020/02/13/python%E8%BF%9B%E9%98%B6/"/>
    <url>/2020/02/13/python%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="数据容器"><a href="#数据容器" class="headerlink" title="数据容器"></a>数据容器</h1><p><strong>List</strong><br><strong>迭代</strong></p><pre><code class="python">li = [&#39;umaru&#39;, &#39;ebina&#39;, &#39;tachibana&#39;]for e in li:    print(li)# umaru ebina tachibana</code></pre><p><strong>同时迭代元素与其索引</strong><br>用 enumerate 即可</p><pre><code class="python">li = [&#39;umaru&#39;, &#39;ebina&#39;, &#39;tachibana&#39;]print([f&#39;{i+1}. {elem}&#39; for i, elem in enumerate(li)])# [&#39;1. umaru&#39;, &#39;2. ebina&#39;, &#39;3. tachibana&#39;]</code></pre><p><strong>同时迭代 2 个以上的 iterable</strong><br>用 zip 即可</p><pre><code class="python">subjects = (&#39;nino&#39;, &#39;miku&#39;, &#39;itsuki&#39;)predicates = (&#39;saikou&#39;, &#39;ore no yome&#39;, &#39;is sky&#39;)print([f&#39;{s} {p}&#39; for s, p in zip(subjects, predicates)])# [&#39;nino saikou&#39;, &#39;miku ore no yome&#39;, &#39;itsuki is sky&#39;]</code></pre><p><strong>iterable 解包</strong><br>最典型的例子就是 2 数交换</p><pre><code class="python">a, b = b, a# 等价于 a, b = (b, a)</code></pre><p>用星号运算符解包可以获取剩余的元素</p><pre><code class="python">first, *rest = [1, 2, 3, 4]first# 1rest# [2, 3, 4]</code></pre><p>用下划线可以忽略某个变量</p><pre><code class="python">filename, _ = &#39;eroge.exe&#39;.split(&#39;.&#39;)filename# &#39;eroge&#39;</code></pre><p><strong>Dict</strong><br><strong>迭代</strong></p><pre><code class="python">d = {&#39;name&#39;: &#39;sekiro&#39;, &#39;hobby&#39;: &#39;blacksmithing&#39;, &#39;tendency&#39;: &#39;death&#39;}[key for key in d.keys()]# [&#39;name&#39;, &#39;hobby&#39;, &#39;tendency&#39;][value for value in d.values()]# [&#39;sekiro&#39;, &#39;blacksmithing&#39;, &#39;death&#39;][f&#39;{key}: {value}&#39; for key, value in d.items()]# [&#39;name: sekiro&#39;, &#39;hobby: blacksmithing&#39;, &#39;tendency: death&#39;]</code></pre><p><strong>缺失键处理</strong><br>get 返回键值，如果键不在字典中，将会返回 None ，可自行设定一个默认值</p><pre><code class="python">d = {&#39;name&#39;: &#39;okabe rintaro&#39;, &#39;motto&#39;: &#39;elpsycongroo&#39;}d.get(&#39;job&#39;, &#39;mad scientist&#39;)# mad scientist</code></pre><p>setdefault 返回键值，如果键不在字典中，将会添加它并设置一个默认值</p><pre><code class="python">d = {&#39;name&#39;: &#39;okabe rintaro&#39;, &#39;motto&#39;: &#39;elpsycongroo&#39;}d.setdefault(&#39;job&#39;, &#39;mad scientist&#39;)# mad scientistd# {&#39;name&#39;: &#39;okabe rintaro&#39;, &#39;motto&#39;: &#39;elpsycongroo&#39;, &#39;job&#39;: &#39;mad scientist&#39;}</code></pre><h1 id="语言专属特性"><a href="#语言专属特性" class="headerlink" title="语言专属特性"></a>语言专属特性</h1><p><strong>推导式</strong><br>推导式是一种快速构建可迭代对象的方法，因此凡是可迭代的对象都支持推导式</p><p><strong>列表推导式</strong><br>获取 0-10 内的所有偶数</p><pre><code class="python">even = [i for i in range(10) if not i % 2]even# [0, 2, 4, 6, 8]</code></pre><p><strong>字典推导式</strong><br>将装满元组的列表转换为字典</p><pre><code class="python">SEIREI = [(0, &#39;takamiya mio&#39;), (1, &#39;tobiichi origami&#39;), (2, &#39;honjou nia&#39;), (3, &#39;tokisaki kurumi&#39;), (4, &#39;yoshino&#39;), (5, &#39;itsuka kotori&#39;), (6, &#39;hoshimiya mukuro&#39;), (7, &#39;natsumi&#39;), (8, &#39;yamai&#39;), (9, &#39;izayoi miku&#39;), (10, &#39;yatogami tohka&#39;)]seirei_code = {seirei: code for code, seirei in SEIREI}seirei_code# {&#39;takamiya mio&#39;: 0, &#39;tobiichi origami&#39;: 1, &#39;honjou nia&#39;: 2, &#39;tokisaki kurumi&#39;: 3, &#39;yoshino&#39;: 4, &#39;itsuka kotori&#39;: 5, &#39;hoshimiya mukuro&#39;: 6, &#39;natsumi&#39;: 7, &#39;yamai&#39;: 8, &#39;izayoi miku&#39;: 9, &#39;yatogami tohka&#39;: 10}{code: seirei.upper() for seirei, code in seirei_code.items() if code &gt; 6}# {7: &#39;NATSUMI&#39;, 8: &#39;YAMAI&#39;, 9: &#39;IZAYOI MIKU&#39;, 10: &#39;YATOGAMI TOUKA&#39;}</code></pre><p><strong>合推导式</strong><br>求所有数字的平方并去除重复元素</p><pre><code class="python">{x ** 2 for x in [1, 2, 2, 3, 3]}# {1, 4, 9}</code></pre><p><strong>生成器表达式</strong><br>求 0-10 内的所有偶数的和</p><pre><code class="python">even_sum_under_10 = sum(i for i in range(11) if not i % 2)even_sum_under_10# 30</code></pre><p><strong>星号和双星号</strong></p><p><strong>数据容器的合并</strong></p><pre><code class="python">l1 = [&#39;kaguya&#39;, &#39;miyuki&#39;]l2 = [&#39;chika&#39;, &#39;ishigami&#39;][*l1, *l2]# [&#39;kaguya&#39;, &#39;miyuki&#39;, &#39;chika&#39;, &#39;ishigami&#39;]d1 = {&#39;name&#39;: &#39;rimuru&#39;}d2 = {&#39;kind&#39;: &#39;slime&#39;}{**d1, **d2}# {&#39;name&#39;: &#39;rimuru&#39;, &#39;kind&#39;: &#39;slime&#39;}</code></pre><p><strong>函数参数的打包与解包</strong></p><pre><code class="python"># 打包def foo(*args):    print(args)foo(1, 2)# (1, 2)def bar(**kwargs):    print(kwargs)bar(name=&#39;hayasaka&#39;, job=&#39;maid&#39;)# {&#39;name&#39;: &#39;hayasaka&#39;, &#39;job&#39;: &#39;maid&#39;}# 解包t = (10, 3)quotient, remainder = divmod(*t)quotient# 商：3remainder# 余：1</code></pre><p><strong>装饰器</strong><br>装饰器是一个可调用的对象，顾名思义它能够装饰在某个可调用的对象上，给它增加额外的功能</p><p>常用于缓存、权限校验、日志记录、性能测试、事务处理等场景</p><p>以下实现了一个简单的日志装饰器，能打印出函数的执行时间、函数名、函数参数和执行结果</p><pre><code class="python">import timefrom functools import wrapsdef clock(func):    @wraps(func) # 防止被装饰函数的属性被wrapper覆盖    def wrapper(*args, **kwargs):        t0 = time.perf_counter()        result = func(*args, **kwargs) # 由于闭包，wrapper函数包含了自由变量func        elapsed = time.perf_counter() - t0        name = func.__name__        args = &#39;, &#39;.join(repr(arg) for arg in args)        kwargs = &#39;, &#39;.join(f&#39;{k}={w}&#39; for k, w in sorted(kwargs.items()))        all_args_str = &#39;, &#39;.join(astr for astr in [args_str, kwargs_str] if astr)        print(f&#39;[{elapsed:.8f}s] {name}({all_args_str}) -&gt; {result}&#39;)        return result    return wrapper # 返回内部函数，取代被装饰的函数@clockdef factorial(n: int) -&gt; int:    return 1 if n &lt; 2 else n * factorial(n-1)factorial(5)# [0.00000044s] factorial(1) -&gt; 1# [0.00011111s] factorial(2) -&gt; 2# [0.00022622s] factorial(3) -&gt; 6# [0.00030844s] factorial(4) -&gt; 24# [0.00042222s] factorial(5) -&gt; 120# 120</code></pre><p>如果想让装饰器能接受参数，那就要再嵌套一层</p><pre><code class="python">import timefrom functools import wrapsDEFAULT_FMT = &#39;[{elapsed:.8f}s] {name}({all_args_str}) -&gt; {result}&#39;def clock(fmt=DEFAULT_FMT):    def decorate(func):        @wraps(func)        def wrapper(*args, **kwargs):            t0 = time.perf_counter()            result = func(*args, **kwargs)            elapsed = time.perf_counter() - t0            name = func.__name__            args_str = &#39;, &#39;.join(repr(arg) for arg in args)            kwargs_str = &#39;, &#39;.join(f&#39;{k}={w}&#39; for k, w in sorted(kwargs.items()))            all_args_str = &#39;, &#39;.join(astr for astr in [args_str, kwargs_str] if astr)            print(fmt.format(**locals()))            return result        return wrapper    return decorate@clock()def factorial_default_fmt(n: int) -&gt; int:    return 1 if n &lt; 2 else n * factorial_default_fmt(n-1)@clock(&#39;{name}: {elapsed}s&#39;)def factorial_customed_fmt(n: int) -&gt; int:    return 1 if n &lt; 2 else n * factorial_customed_fmt(n-1)factorial_default_fmt(3)# [0.00000044s] factorial_default_fmt(1) -&gt; 1# [0.00009600s] factorial_default_fmt(2) -&gt; 2# [0.00018133s] factorial_default_fmt(3) -&gt; 6# 6factorial_customed_fmt(3)# factorial_customed_fmt: 4.444450496521313e-07s# factorial_customed_fmt: 9.733346314533264e-05s# factorial_customed_fmt: 0.0001831113553407704s# 6</code></pre><p>在 django 中，可以通过装饰器对函数视图进行功能增强（比如@login_required 进行登录的权限校验，@cache_page 进行视图的缓存等）</p><p><strong>上下文管理器</strong><br>用于资源的获取与释放，以代替 try-except 语句</p><p>常用于文件 IO，锁的获取与释放，数据库的连接与断开等</p><pre><code class="python"># try:#     f = open(input_path)#     data = f.read()# finally:#     f.close()with open(input_path) as f:    data = f.read()</code></pre><p>其实在 pathlib 里已经给我们封装好了文件 IO 方法</p><pre><code class="python"># with open(&#39;file&#39;) as i:#     data = i.read()from pathlib import Pathdata = Path(&#39;file&#39;).read_text()</code></pre><p>至于上下文管理器的实现，可以用@contextmanager</p><pre><code class="python">from contextlib import contextmanager@contextmanagerdef open_write(filename):    try:        f = open(filename, &#39;w&#39;)        yield f    finally:        f.close()with open_write(&#39;onegai.txt&#39;) as f:    f.write(&#39;Dagakotowaru!&#39;)</code></pre><p><strong>多重继承</strong></p><p>在 django 中经常要处理类的多重继承的问题，这时就要用到 super 函数</p><p>如果单单认为 super 仅仅是“调用父类的方法”，那就错了</p><p>在继承单个类的情况下，可以认为 super 是调用父类的方法（ES6 里面亦是如此）</p><p>但多重继承就不一样了，因为方法名可能会有冲突，所以 super 就不能单指父类了</p><p><strong>在 Python 中，super 指的是 MRO 中的下一个类</strong>，用来解决多重继承时父类的查找问题</p><p>MRO 是啥？Method Resolution Order（方法解析顺序）</p><p>看完下面的例子，就会理解了</p><pre><code class="python">class A:    def __init__(self):        print(&#39;A&#39;)class B(A):    def __init__(self):        print(&#39;enter B&#39;)        super().__init__()        print(&#39;leave B&#39;)class C(A):    def __init__(self):        print(&#39;enter C&#39;)        super().__init__()        print(&#39;leave C&#39;)class D(B, C):    passd = D()# enter B# enter C# A# leave C# leave Bprint(d.__class__.__mro__)# (&lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;)</code></pre><p>首先，因为 D 继承了 B 类，所以调用 B 类的<strong>init</strong>，打印了enter B</p><p>打印enter B后的 super 寻找 MRO 中的 B 的下一个类，也就是 C 类，并调用其<strong>init</strong>，打印enter C</p><p>打印enter C后的 super 寻找 MRO 中的 C 的下一个类，也就是 A 类，并调用其<strong>init</strong>，打印A</p><p>打印A后回到 C 的<strong>init</strong>，打印leave C</p><p>打印leave C后回到 B 的<strong>init</strong>，打印leave B</p><p><strong>特殊方法</strong><br>在 django 中，定义 model 的时候，希望 admin 能显示 model 的某个字段而不是 XXX Object，那么就要定义好<strong>str</strong></p><p>每当你使用一些内置函数时，都是在调用一些特殊方法，例如 len()调用了<strong>len</strong>(), str()调用<strong>str</strong>()等</p><p>以下实现一个 2d 数学向量类，里面有多个特殊方法</p><pre><code class="python">from math import hypotclass Vector2d:    # 限制允许绑定的属性    __slots__ = (&#39;__x&#39;, &#39;__y&#39;)    # 实例创建    def __init__(self, x, y):        self.__x = float(x)        self.__y = float(y)    # 前双下划线是私有属性，property装饰是只读属性    @property    def x(self):        return self.__x    @property    def y(self):        return self.__y    # 可迭代对象    def __iter__(self):        yield from (self.x, self.y)    # 字符串表示形式    def __repr__(self) -&gt; str:        return f&#39;{type(self).__name__}({self.x}, {self.y})&#39;    # 数值转换 - 绝对值    def __abs__(self) -&gt; float:        return hypot(self.x, self.y)    # 数值转换 - 布尔值    def __bool__(self) -&gt; bool:        return bool(abs(self))    # 算术运算符 - 加    def __add__(self, other):        x = self.x + other.x        y = self.y + other.y        return Vector2d(x, y)    # 算术运算符 - 乘    def __mul__(self, scalar: float):        return Vector2d(self.x * scalar, self.y * scalar)    # 比较运算符 - 相等    def __eq__(self, other):        return tuple(self) == tuple(other)    # 可散列    def __hash__(self):        return hash(self.x) ^ hash(self.y)v = Vector2d(3, 4)# __slots__限制了允许绑定的属性，只能是x或yv.z = 1# Traceback (most recent call last):#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;# AttributeError: &#39;Vector2d&#39; object has no attribute &#39;z&#39;# 由于x属性只读，因此无法再次赋值v.x = 1# Traceback (most recent call last):#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;# AttributeError: can&#39;t set attribute# iter(v) =&gt; v.__iter__()x, y = v# x为3, y为4# repr(v) =&gt; v.__repr__()v# Vector2d(3, 4)# abs(v) =&gt; v.__abs__()abs(v)# 5.0# bool(v) =&gt; v.__bool__()bool(v)# True# v1 + v2  =&gt; v1.__add__(v2)v1 = Vector2d(1, 2)v2 = Vector2d(3, 4)v1 + v2# Vector2d(4, 6)# v * 3  =&gt; v.__mul__(3)v * 3# Vector2d(9, 12)# v1 == v2 =&gt; v1.__eq__(v2)v1 = Vector2d(1, 2)v2 = Vector2d(1, 2)v1 == v2# True# hash(v) =&gt; v.__hash__()hash(v)# 7v1 = Vector2d(1, 2)v2 = Vector2d(3, 4)set([v1, v2])# {Vector2d(1.0, 2.0), Vector2d(3.0, 4.0)}</code></pre><p>如果把 Vector 改造为多维向量呢？关键就是要实现序列协议（<strong>len</strong>和<strong>getitem</strong>）</p><p>协议：本质上是<a href="https://baike.baidu.com/item/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/10845665?fr=aladdin" target="_blank" rel="noopener">鸭子类型</a>语言使用的非正式接口</p><p>不仅如此，还要实现多分量的获取以及散列化</p><pre><code class="python">from array import arrayimport reprlibimport mathimport numbersimport stringfrom functools import reducefrom operator import xorfrom itertools import zip_longestimport numbersfrom fractions import Fraction as Fclass Vector:    typecode = &#39;d&#39;    shortcut_names = &#39;xyzt&#39;    def __init__(self, components):        self._components = array(self.typecode, components)    def __iter__(self):        return iter(self._components)    def __repr__(self):        components = reprlib.repr(self._components)        components = components[components.find(&#39;[&#39;):-1]        return f&#39;{type(self).__name__}({components})&#39;    def __str__(self):        return str(tuple(self))    def __eq__(self, other):        return tuple(self) == tuple(other)    def __bool__(self):        return bool(abs(self))    # 序列协议 - 获取长度    def __len__(self):        return len(self._components)    # 序列协议 - 索引取值    def __getitem__(self, index):        cls = type(self)  # Vector        if isinstance(index, slice):  # 索引是slice对象，则返回Vector实例            return cls(self._components[index])        elif isinstance(index, numbers.Integral):  # 索引是整数类型，则返回_components中对应的数字            return self._components[index]        else:            raise TypeError(f&#39;{cls.__name__} indices must be integers.&#39;)    # 属性访问，获取分量的值    def __getattr__(self, name):        cls = type(self)        if len(name) == 1:            pos = cls.shortcut_names.find(name)            if 0 &lt;= pos &lt; len(self._components):                return self._components[pos]        raise AttributeError(f&#39;{cls.__name__} has no attribute {name}&#39;)    # 属性设置，给分量设值时会抛出异常，使向量是不可变的    def __setattr__(self, name, value):        cls = type(self)        if len(name) == 1:            if name in string.ascii_lowercase:                raise AttributeError(f&quot;can&#39;t set attribute &#39;a&#39; to &#39;z&#39; in {cls.__name__}&quot;)        super().__setattr__(name, value)    # 比较所有分量，都相等才算两向量相等    def __eq__(self, other):        return len(self) == len(other) and all(a == b for a, b in zip(self, other))    # 散列化    def __hash__(self):        hashes = map(hash, self._components)        return reduce(xor, hashes, 0)    # 绝对值    def __abs__(self):        return math.sqrt(sum(x ** 2 for x in self))    # 取正    def __pos__(self):        return Vector(self)    # 取负    def __neg__(self):        return Vector(-x for x in self)    # 加 (减法__sub__的实现与之类似，略)    def __add__(self, other):        try:            return Vector(a + b for a, b in zip_longest(self, other, fillvalue=0.0))        except TypeError:            return NotImplemented    # 反向加（a+b中，如果a没有__add__或返回NotImplemented，则检查b是否有__radd__，有则调用之）    def __radd__(self, other):        return self + other    # 乘 (除法__truediv__的实现与之类似，略)    def __mul__(self, scalar):        return Vector(n * scalar for n in self) if isinstance(scalar, numbers.Real) else NotImplemented    # 反向乘    def __rmul__(self, scalar):        return self * scalar    # 中缀运算符@ - 点积    def __matmul__(self, other):        try:            return sum(a * b for a, b in zip(self, other))        except TypeError:            return NotImplemented    # 反向中缀运算符@    def __rmatmul__(self, other):        return self @ otherv = Vector(range(7))v# Vector([0.0, 1.0, 2.0, 3.0, 4.0, ...])v[1:3]# Vector([1.0, 2.0])v[-1]# 6.0v[1,3]# Traceback (most recent call last):#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;#   File &quot;&lt;stdin&gt;&quot;, line 39, in __getitem__# TypeError: Vector indices must be integers.v.x, v.y, v.z# (0.0, 1.0, 2.0)v.x = 1# Traceback (most recent call last):#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;#   File &quot;&lt;stdin&gt;&quot;, line 62, in __setattr__# AttributeError: can&#39;t set attribute &#39;a&#39; to &#39;z&#39; in Vectorv1 = Vector((3, 4, 5))v2 = Vector((6, 7))v1 == v2# Falseset([v1, v2])# {Vector([6.0, 7.0]), Vector([3.0, 4.0, 5.0])}abs(v)# 9.539392014169456+v# Vector([0.0, 1.0, 2.0, 3.0, 4.0, ...])-v# Vector([-0.0, -1.0, -2.0, -3.0, -4.0, ...])v1 + v2# Vector([9.0, 11.0, 5.0])v * 3# Vector([0.0, 3.0, 6.0, 9.0, 12.0, ...])v * F(1, 2)# Vector([0.0, 0.5, 1.0, 1.5, 2.0, ...])v1 @ v2# 46.0</code></pre><p>想了解所有的特殊方法可查阅<a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" target="_blank" rel="noopener">官方文档</a>,以下列举些常用的：</p><pre><code class="python">字符串表示形式：__str__, __repr__数值转换：__abs__, __bool__, __int__, __float__, __hash__集合模拟：__len__, __getitem__, __setitem__, __delitem__, __contains__迭代枚举：__iter__, __reversed__, __next__可调用模拟：__call__实例创建与销毁：__init__, __del__属性访问：__getattr__, __setattr__运算符相关：__add__, __radd__, __mul__, __rmul__, __matmul__, __rmatmul__, ...</code></pre><p><strong>类方法和静态方法</strong><br>@classmethod 是类方法，它定义操作类的方法，也就是说会将类绑定给方法，而不是实例</p><p>@staticmethod 是静态方法，啥都不绑定，一般用来给类绑定各种工具方法（不涉及对实例和类的操作）</p><p>在 django 中，我们经常要在视图函数中对模型类进行各种查询</p><p>然而，很多查询都是重复的代码，根据 DRY 原则，它们都是可以被封装的</p><p>那么，如果我们要给模型类封装一些查询操作，就要用到@classmethod</p><p>以下是 Post 类，里面定义了 latest_posts 方法用来获取最新的几个 Post</p><p>这样在视图函数中，就能直接调用该方法进行查询，节省了不少代码</p><pre><code class="python">class Post(models.Model):    STATUS_NORMAL = 1    STATUS_DELETE = 0    STATUS_DRAFT = 2    STATUS_ITEMS = (        (STATUS_NORMAL, &#39;正常&#39;),        (STATUS_DELETE, &#39;删除&#39;),        (STATUS_DRAFT, &#39;草稿&#39;),    )    ...    status = models.PositiveIntegerField(_(&quot;状态&quot;), choices=STATUS_ITEMS, default=STATUS_NORMAL)    created_time = models.DateTimeField(_(&quot;创建时间&quot;), auto_now_add=True)    ...    @classmethod    def latest_posts(cls, limit=None):        queryset = cls.objects.filter(status=cls.STATUS_NORMAL).order_by(&#39;-created_time&#39;)        if limit:            queryset = queryset[:limit]        return queryset</code></pre><p><strong>描述符</strong><br>实现了<strong>set</strong>或<strong>get</strong>协议的类就是描述符</p><p>set 和 get 代表存和取，因此描述符是一种对多个类属性运用相同存取逻辑的一种方式</p><p>例如 django 的 ORM 中的字段类型是描述符，用来把数据库记录中的字段数据与 Python 对象的属性对应起来</p><p>以下实现一个简单的描述符类，用来在读写属性时验证属性的正确性</p><pre><code class="python">class Validator:    def __init__(self, storage_name):        self.storage_name = storage_name    def __set__(self, instance, value):        if not isinstance(value, int):            raise ValueError(&#39;Value must be an integer&#39;)        if value &gt; 200:            raise ValueError(&#39;Value must be under 200&#39;)class Person:    age = Validator(&#39;age&#39;)    def __init__(self, age):        self.age = ageperson = Person(age=100)person.age = &#39;young&#39;# Traceback (most recent call last):# ValueError: Value must be an integerperson.age = 201# Traceback (most recent call last):# ValueError: Value must be under 200</code></pre><p><strong>元类</strong></p><p>进入元类这个概念之前，我们先回顾一下 type()这个函数，不，其实它是个类</p><p>通过 type()，我们可以获取一个对象所属的类，但通过 help 函数，发现 type()居然也可以用来创建类！</p><pre><code class="python">type(name, bases, dict) -&gt; a new type</code></pre><p>name 是新类的名称，bases 是继承的子类，dict 则是新类的属性名与其对应值的字典</p><pre><code class="python">class A:    a = 1    def foo(self):        return self.a * 2# 以上类的创建等价于A = type(&#39;A&#39;, (object, ), {&#39;a&#39;: 1, &#39;foo&#39;: lambda self: self.a * 2})</code></pre><p>那么什么是元类呢？</p><p>平时我们用类来创建对象，但一切类都继承了对象，说白了类也是对象，而元类就是用来创建类对象的类</p><p>说白了，元类就是制造类的工厂</p><pre><code class="python">&#39;alphardex&#39;.__class__# &lt;class &#39;str&#39;&gt;&#39;alphardex&#39;.__class__.__class__# &lt;class &#39;type&#39;&gt;</code></pre><p>通过以上的例子我们知道 type 就是用来创造一切类的元类，它是 Python 内置的元类</p><p>既然有内置的元类，也意味着你也可以自定义元类</p><p>以下实现一个元类，用来把类的所有非私有属性自动转换为大写（不已_开头的属性都是非私有的）</p><p>思路很简单：把属性和对应的值字典(attrs)里的非私有属性键改为大写(upper)就行了</p><pre><code class="python">class UpperAttrMeta(type):    def __new__(cls, name, bases, attrs):        &quot;&quot;&quot;        __init__方法用来初始化对象并传入参数        而__new__方法专门用来创建对象（显然这里我们要创建一个类对象并定制它）        &quot;&quot;&quot;        upper_attrs = {k.upper() if not k.startswith(&#39;_&#39;) else k: v for k, v in attrs.items()}        return super().__new__(cls, name, bases, upper_attrs)class Foo(metaclass=UpperAttrMeta):    name = &#39;alphardex&#39;    __love = &#39;unknown&#39;f = Foo()f.NAME# &#39;alphardex&#39;f._Foo__love# &#39;unknown&#39;</code></pre><p>元类的最经典的用途就是 ORM 的实现，以 django 的 ORM 为例</p><pre><code class="python">class Person(models.Model):    name = models.CharField(max_length=30)    age = models.IntegerField()p = Person(name=&#39;alphardex&#39;, age=&#39;24&#39;)p.age# 24</code></pre><p>如果你访问一个模型实例的属性（例如这里的 age），你并不会得到什么 IntegerField()，而是得到了 24 这个数字，这就是元类的作用</p><p>元类平时很少用到，如果要动态修改类的属性，可以用猴子补丁（直接修改类方法）或者类装饰器</p><p>当然，这并不代表元类没什么用，想用到它的时候自然会用到的</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
