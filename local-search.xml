<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>抖音是如何&#39;绑架&#39;我们的</title>
    <link href="/2020/02/13/%E6%8A%96%E9%9F%B3%E6%98%AF%E5%A6%82%E4%BD%95-%E7%BB%91%E6%9E%B6-%E6%88%91%E4%BB%AC%E7%9A%84/"/>
    <url>/2020/02/13/%E6%8A%96%E9%9F%B3%E6%98%AF%E5%A6%82%E4%BD%95-%E7%BB%91%E6%9E%B6-%E6%88%91%E4%BB%AC%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>原文链接： <a href="http://dy.163.com/v2/article/detail/DHEL7NKB0518U04N.html" target="_blank" rel="noopener">http://dy.163.com/v2/article/detail/DHEL7NKB0518U04N.html</a></p><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>这篇文中，抖音只是一个具象化代表，</p><p>​ 我想讲的是以抖音为代表的一众以算法为内核的娱乐化APP。</p><p>　　每个时代都会有一些淘汰机制，</p><p>　　而现在的时代，</p><p>　　会根据自制力和信息筛选能力对人进行淘汰。</p><p>　　但总有一些人是不愿惊醒的，</p><p>　　等他们发现自己一事无成时，</p><p>　　会选择抱怨别人、抱怨社会、然后把希望寄托给下一代，</p><p>　　在这群人眼里错的不是他们，</p><p>　　而是社会。</p><p>　　希望这个人不会是你。</p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>前几天抖音出了一个“爆视频”，单单评论数就超过一百万，播放数量过千万。</p><p>　　这几乎是我们这些文字工作者难以企及的数量。而数量背后，潜藏着一个个为此付出时间与精力的人。<br><img src="/img/content/douyin/1.png" srcset="/img/loading.gif" alt=""></p><p>除此之外，相信你在朋友圈也看到过不少这样的话：</p><p>　　“中了抖音的毒”、“刷抖音根本停不下来啊啊啊，一看表竟然刷了三个多小时……”</p><p><img src="/img/content/douyin/2.png" srcset="/img/loading.gif" alt=""></p><p>这一点相信刷过抖音、亦或者是刷过快手、火山小视频等等各种小视频软件的人都会深有感受。</p><p>　　如果你在路边、休息处看到一个人手指连动笑的合不拢嘴，那大概就是在刷小视频了。</p><p>　　我们会不自觉的深陷其中，蓦然之间发现时间已经过去了几个小时。</p><p>　　尼尔·波兹曼在《娱乐至死》里这样写过这样的一段话：</p><blockquote><p>“一切公众话语日渐以娱乐的方式出现，并成为一种文化精神。我们的政治、宗教、新闻、体育、教育和商业都心甘情愿地成为娱乐的附庸，毫无怨言，甚至无声无息，其结果是我们成了一个娱乐至死的物种。”</p></blockquote><p>层次越低的人，越喜欢花时间在娱乐上。</p><p>　　越来越多的人患上了网络依存症，对各类娱乐新闻上瘾、产生依赖，人云亦云，附和跟风，沉溺在虚拟的世界中不能自拔。</p><p>　　我害怕长久以往，自己会变成一个透明的躯壳，脑袋空空、沉浸于感官娱乐。</p><p>　　有人说，你的时间花在哪，你就会成为什么样的人。格局高的人，不会花太多时间在娱乐上。</p><p>　　深以为然。</p><p>　　我们正在爱上这些使我们丧失思考能力的工业技术。</p><p>　　抖音、快手、抖音、微博这些软件正在飞速地强化我们对新奇事物的需求度，并拉高我们的敏感度。</p><p>　　同时降低的就是对文字的需求度与耐心度。</p><p>　　刷多了抖音、快手、微博这些软件之后，我们就会形成一种惯性：没有耐心去读一本长文或者书籍。更没有时间去思考，因为我们总是在期待着下一个引爆眼球的新奇事物，等待着它在视频中直接了当的呈现。</p><p>　　比如你就有可能看不完我的这篇长文。</p><p>　　而在被轰炸多了之后，我们就会逐渐爱上这种“被喂食”的感觉。</p><p>　　而当“被喂食”形成一种习惯之后，我们的就会惰于思考，耐心以及深挖问题的能力就会被逐渐抹杀。</p><p>　　还记得盛大公司吗？</p><p><img src="/img/content/douyin/3.png" srcset="/img/loading.gif" alt="陈天桥"></p><p>　　这是一家十分“传奇”的公司，2001年年底，盛大账面上只剩下大约30万美金，陈天桥倾囊而出，买下韩国一款二线游戏《传奇》的中国代理权。</p><p>　　2002年，《传奇》同时在线人数突破60万，成为当时世界上最大规模的网络游戏，盛大月均销售额超过千万，市场占有率超过六成。</p><p>　　但是陈天桥在接受记者采访时却不止一次说过：“我从来不玩《传奇》，因为这是个烂游戏，浪费我的时间，但是盛大是个好公司”</p><p>　　但是不可否认的是，这个备受追捧的烂游戏确实吸来了千万销售额。</p><p>　　<strong>看到了么？你每时每刻傻呵呵的沉浸其中，换来的都是经营者的盆满钵满。</strong></p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>“不知道为什么，刷抖音的时候感觉那么开心，可是刷完之后却分外空虚，变得很丧，而且更自卑了”一个粉丝在凌晨一点多私信我。</p><p>　　他说他刚在床上刷完抖音，然后就失眠了。</p><p>　　在孤寂无人的夜晚，我们最容易感受到自己的无助与空虚。</p><p>　　我回复说：“因为你爱上了一个虚拟且充满新奇G点世界，但是你依旧碌碌无为，你的生活仍然平平无奇。”</p><p>　　我称抖音、火山小视频、今日头条、快手等等以算法推荐为内核的软件为：毒品软件。</p><p>　　一款类似抖音的 APP，背后都是一个强大的运营团队，有着专业的消费者行为学作支撑，用尽最前沿的科技，最详尽的数据，通过声、光、交互、反馈等全方位途径，在各种心理学、行为经济学、认知神经科学等理论指导下，精心打造 —— 目的是什么？为了创造一个虚拟空间，来消磨你的时间。</p><p>　　它带来的满足感太容易获得，而一旦你习惯了这种“唾手可得”的满足感，就不愿再去做那些“高投入”的事情了。比如在高度自律的状态下完成作业、思考问题。</p><p>　　在这个被娱乐塞满的世界里，当没有足够强大的自控力时，我们就会因为沉迷各种诱惑而“被碌碌无为”。</p><p>　　比尔盖茨曾在采访中说过，他认为13岁是孩子拥有第一部手机的合适年龄。</p><p><img src="/img/content/douyin/4.png" srcset="/img/loading.gif" alt="比尔盖茨和女儿"></p><p>　　他、珍妮弗、以及1999年出生的儿子罗里·盖茨都是在过了13岁生日后才被允许使用手机，小女儿菲比则在期待着13岁生日时得到自己的第一部手机。</p><p>　　“我们家把13岁定为得到手机的年限。”盖茨说，鉴于这项规定，孩子们从学校回家后常向他抱怨说，“其他孩子都有手机，我是唯一一个没有手机的人，这令人尴尬”。</p><p>　　<strong>你知道吗？乔布斯是不允许自己的孩子们用iPad的。</strong></p><p><img src="/img/content/douyin/5.png" srcset="/img/loading.gif" alt=""></p><p>乔布斯生前有三个年幼的孩子。有一天纽约时报的记者Nick Bilto问他：</p><blockquote><p>“你的孩子们一定很喜欢iPad吧？”</p></blockquote><p>老乔回答：</p><blockquote><p>“他们没有用过。我们限制孩子们在家里使用智能产品。”</p></blockquote><p>　　听起来是不是怪怪的？iPad之父居然不允许自己的孩子用iPad?感觉就像是毒贩不允许自己的孩子吸毒一样….</p><p>　　无独有偶。<strong>在硅谷，很多高科技公司的高层和工程师里面，开始流行不让自己的孩子接触智能科技产品。</strong></p><p>　　他们甚至把孩子们送到传统的，完全没有智能和科技产品的Waldorf学校，在这个学校的校园里根本就找不到电脑！</p><p>　　我们看到的是电子产品正在飞速低龄化，抖音快手已经迅速占据了小学生的生活。</p><p><img src="/img/content/douyin/6.png" srcset="/img/loading.gif" alt=""></p><p>而因为缺乏自制力，他们会沉浸其中无法自拔，在最应当拼搏的年纪里选择安逸，在价值观形成之际被灌输进大量的光怪陆离与不正之风。</p><p>　　于是他们开始模仿，追逐着未成年怀孕风当宝妈、跟着小青年跳社会摇、以为低胸博眼球就能赚大钱……当管制不利时，堕落便自此开始。</p><p>　　那些我们所热爱的东西，正在一步步把我们连根拔起。</p><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>在作家周冲的文章中看到过这样一段话：</p><blockquote><p>当你的时间不再用于深度学习，当你的注意力被他人瓜分，当你只看综艺与电视剧，当你在群体中呆的时间越来越长，当你执行力越来越差，当你评价他人的次数越来越多，当你抱怨越来越频繁，当你回想往事的频率越来越高……毁灭就已经发生了。</p></blockquote><p>　　如何分配你的时间，取决于你。</p><p>　　罗振宇说，未来，在时间这个战场上，有两门生意会特别值钱。</p><p>　　第一，就是帮别人省时间。第二，就是帮别人把省下来的时间浪费在那些美好的事物上。</p><p>　　能够掌控时间的人，才能掌控自己的一生。</p><p>　　这座城市，一半人在拼命，一半人在认命；一半人在抢时间，一半人在耗时间；一半人在燃烧青春，一半人在虚度青春。</p><p>　　你愿意做哪一半的人？</p>]]></content>
    
    
    
    <tags>
      
      <tag>推文</tag>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据分析入门</title>
    <link href="/2020/02/13/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/"/>
    <url>/2020/02/13/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="更新中…"><a href="#更新中…" class="headerlink" title="更新中…"></a>更新中…</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Matplotlib介绍与使用</title>
    <link href="/2020/02/13/Matplotlib%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/02/13/Matplotlib%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="更新中…"><a href="#更新中…" class="headerlink" title="更新中…"></a>更新中…</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Numpy使用</title>
    <link href="/2020/02/13/Numpy%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/02/13/Numpy%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="更新中…"><a href="#更新中…" class="headerlink" title="更新中…"></a>更新中…</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>panda和Dataframe使用</title>
    <link href="/2020/02/13/panda%E5%92%8CDataframe%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/02/13/panda%E5%92%8CDataframe%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="更新中…"><a href="#更新中…" class="headerlink" title="更新中…"></a>更新中…</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>物联网数据传输、存储和展示</title>
    <link href="/2020/02/13/%E7%89%A9%E8%81%94%E7%BD%91%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%AD%98%E5%82%A8-EMQ-telegraf-influxdb%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/02/13/%E7%89%A9%E8%81%94%E7%BD%91%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%AD%98%E5%82%A8-EMQ-telegraf-influxdb%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="一、开源MQTT消息服务器——EMQ"><a href="#一、开源MQTT消息服务器——EMQ" class="headerlink" title="一、开源MQTT消息服务器——EMQ"></a>一、开源MQTT消息服务器——EMQ</h1><p>官网链接：<a href="https://www.emqx.io/cn/" target="_blank" rel="noopener">https://www.emqx.io/cn/</a><br>官方文档：<a href="https://docs.emqx.io/broker/latest/cn/" target="_blank" rel="noopener">https://docs.emqx.io/broker/latest/cn/</a><br><img src="/img/content/chuanshu/emq.png" srcset="/img/loading.gif" alt=""></p><p>EMQ X (Erlang/Enterprise/Elastic MQTT Broker) 是基于 Erlang/OTP 语言平台开发，支持大规模连接和分布式集群，发布订阅模式的开源 MQTT 消息服务器。</p><blockquote><p>注解</p></blockquote><blockquote><p>3.0 版本开始 emqttd 消息服务器自正式更名为 EMQ X</p></blockquote><p>EMQ X 消息服务器完整支持 MQTT V3.1/V3.1.1/V5.0 版本协议规范，并扩展支持 MQTT-SN 、WebSocket、CoAP、LwM2M、Stomp 以及私有 TCP/UDP 协议。EMQ X 消息服务器支持单节点100万连接与多节点分布式集群。</p><p>EMQ X 消息服务器为大规模设备连接 (C1000K+) 的物联网、车联网、智能硬件、移动推送、移动消息等应用，提供完全开放源码、安装部署简便、企业级稳定可靠、可弹性扩展、易于定制开发的 MQTT 消息服务器。</p><blockquote><p>注解</p></blockquote><blockquote><p>MQTT-SN、CoAP 协议已在2.0-rc.1版本发布，LwM2M、LoRaWan 协议在 3.0 版本发布。</p></blockquote><p><img src="/img/content/chuanshu/emqtt.png" srcset="/img/loading.gif" alt=""></p><h1 id="二、数据采集工具——Telegraf"><a href="#二、数据采集工具——Telegraf" class="headerlink" title="二、数据采集工具——Telegraf"></a>二、数据采集工具——Telegraf</h1><p>官网链接：<a href="https://www.influxdata.com/time-series-platform/telegraf/" target="_blank" rel="noopener">https://www.influxdata.com/time-series-platform/telegraf/</a><br><img src="/img/content/chuanshu/telegraf.png" srcset="/img/loading.gif" alt=""></p><p>Telegraf 是收集和报告指标和数据的代理。</p><p>Telegraf是TICK Stack的一部分，是一个插件驱动的服务器代理，用于收集和报告指标。</p><p>Telegraf 集成了直接从其运行的容器和系统中提取各种指标，事件和日志，从第三方API提取指标，甚至通过StatsD和Kafka消费者服务监听指标。</p><p>它还具有输出插件，可将指标发送到各种其他数据存储，服务和消息队列，包括InfluxDB，Graphite，OpenTSDB，Datadog，Librato，Kafka，MQTT，NSQ等等。</p><p><img src="/img/content/chuanshu/telegraf_tushi.png" srcset="/img/loading.gif" alt=""></p><h1 id="三、时序数据库——Influxdb"><a href="#三、时序数据库——Influxdb" class="headerlink" title="三、时序数据库——Influxdb"></a>三、时序数据库——Influxdb</h1><p>官网链接：<a href="https://www.influxdata.com/products/influxdb-overview/" target="_blank" rel="noopener">https://www.influxdata.com/products/influxdb-overview/</a><br><img src="/img/content/chuanshu/influxdb.png" srcset="/img/loading.gif" alt=""></p><p>Influxdb 是一个开源的分布式时序、时间和指标数据库，使用 Go 语言编写，无需外部依赖。</p><h2 id="3-1-Influxdb特性："><a href="#3-1-Influxdb特性：" class="headerlink" title="3.1 Influxdb特性："></a>3.1 Influxdb特性：</h2><p>①、基于时间序列，支持与时间有关的相关函数（如最大，最小，求和等）；</p><p>②、可度量性：你可以实时对大量数据进行计算；</p><p>③、基于事件：它支持任意的事件数据；</p><h2 id="3-2-为什么要用telegraf和influxdb？"><a href="#3-2-为什么要用telegraf和influxdb？" class="headerlink" title="3.2 为什么要用telegraf和influxdb？"></a>3.2 为什么要用telegraf和influxdb？</h2><p>①、在数据采集和平台监控系统中，Telegraf 可以采集多种组件的运行信息，而不需要自己手写脚本定时采集，降低数据获取的难度；</p><p>②、Telegraf 配置简单，只要有基本的 Linux 基础即可快速上手；</p><p>③、Telegraf 按照时间序列采集数据，数据结构中包含时序信息，influxdb就是为此类数据设计而来，使用 Influxdb 可以针采集得到的数据完成各种分析计算操作。</p><h1 id="四、-可视化工具——Grafana"><a href="#四、-可视化工具——Grafana" class="headerlink" title="四、 可视化工具——Grafana"></a>四、 可视化工具——Grafana</h1><p>官网地址：<a href="https://grafana.com/" target="_blank" rel="noopener">https://grafana.com/</a><br><img src="/img/content/chuanshu/grafana.png" srcset="/img/loading.gif" alt=""></p><p>Grafana是一个跨平台的开源的度量分析和可视化工具，可以通过将采集的数据查询然后可视化的展示，并及时通知。它主要有以下六大特点：</p><p>1、展示方式：快速灵活的客户端图表，面板插件有许多不同方式的可视化指标和日志，官方库中具有丰富的仪表盘插件，比如热图、折线图、图表等多种展示方式；</p><p>2、数据源：Graphite，InfluxDB，OpenTSDB，Prometheus，Elasticsearch，CloudWatch和KairosDB等；</p><p>3、通知提醒：以可视方式定义最重要指标的警报规则，Grafana将不断计算并发送通知，在数据达到阈值时通过Slack、PagerDuty等获得通知；</p><p>4、混合展示：在同一图表中混合使用不同的数据源，可以基于每个查询指定数据源，甚至自定义数据源；</p><p>5、注释：使用来自不同数据源的丰富事件注释图表，将鼠标悬停在事件上会显示完整的事件元数据和标记；</p><p>6、过滤器：Ad-hoc过滤器允许动态创建新的键/值过滤器，这些过滤器会自动应用于使用该数据源的所有查询。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mqtt，influxdb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物联网传输协议：mqtt入门</title>
    <link href="/2020/02/13/mqtt%E6%A6%82%E8%BF%B0%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/02/13/mqtt%E6%A6%82%E8%BF%B0%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h1><p> MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的“轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p><p> MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。<br><img src="/img/content/mqtt/1.png" srcset="/img/loading.gif" alt=""></p><h1 id="二、设计规范"><a href="#二、设计规范" class="headerlink" title="二、设计规范"></a>二、设计规范</h1><p>由于物联网的环境是非常特别的，所以MQTT遵循以下设计原则：</p><p>（1）精简，不添加可有可无的功能；</p><p>（2）发布/订阅（Pub/Sub）模式，方便消息在传感器之间传递；</p><p>（3）允许用户动态创建主题，零运维成本；</p><p>（4）把传输量降到最低以提高传输效率；</p><p>（5）把低带宽、高延迟、不稳定的网络等因素考虑在内；</p><p>（6）支持连续的会话控制；</p><p>（7）理解客户端计算能力可能很低；</p><p>（8）提供服务质量管理；</p><p>（9）假设数据不可知，不强求传输数据的类型与格式，保持灵活性。</p><h1 id="三、主要特性"><a href="#三、主要特性" class="headerlink" title="三、主要特性"></a>三、主要特性</h1><p> MQTT协议工作在低带宽、不可靠的网络的远程传感器和控制设备通讯而设计的协议，它具有以下主要的几项特性：</p><p>（1）使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。</p><p> 这一点很类似于XMPP，但是MQTT的信息冗余远小于XMPP，,因为XMPP使用XML格式文本来传递数据。</p><p>（2）对负载内容屏蔽的消息传输。</p><p>（3）使用TCP/IP提供网络连接。</p><p> 主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。</p><p>（4）有三种消息发布服务质量：</p><p> “至多一次”，消息发布完全依赖底层TCP/IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。</p><p> “至少一次”，确保消息到达，但消息重复可能会发生。</p><p> “只有一次”，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别。在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP的推送，确保用户收到且只会收到一次。</p><p>（5）小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量。</p><p> 这就是为什么在介绍里说它非常适合“在物联网领域，传感器与服务器的通信，信息的收集”，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了。</p><p>（6）使用Last Will和Testament特性通知有关各方客户端异常中断的机制。</p><p>Last Will：即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接。</p><p>Testament：遗嘱机制，功能类似于Last Will。</p><h1 id="四、MQTT协议原理"><a href="#四、MQTT协议原理" class="headerlink" title="四、MQTT协议原理"></a>四、MQTT协议原理</h1><h2 id="4-1-MQTT协议实现方式"><a href="#4-1-MQTT协议实现方式" class="headerlink" title="4.1 MQTT协议实现方式"></a>4.1 MQTT协议实现方式</h2><p> 实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。</p><p>MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：</p><p>（1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）；</p><p>（2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。</p><h2 id="4-2-网络传输与应用消息"><a href="#4-2-网络传输与应用消息" class="headerlink" title="4.2 网络传输与应用消息"></a>4.2 网络传输与应用消息</h2><p> MQTT会构建底层网络传输：它将建立客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输。</p><p>当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（QoS）和主题名（Topic）相关连。</p><h2 id="4-3MQTT客户端"><a href="#4-3MQTT客户端" class="headerlink" title="4.3MQTT客户端"></a>4.3MQTT客户端</h2><p> 一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以：</p><p>（1）发布其他客户端可能会订阅的信息；</p><p>（2）订阅其它客户端发布的消息；</p><p>（3）退订或删除应用程序的消息；</p><p>（4）断开与服务器连接。</p><h2 id="4-4-MQTT服务器"><a href="#4-4-MQTT服务器" class="headerlink" title="4.4 MQTT服务器"></a>4.4 MQTT服务器</h2><p> MQTT服务器以称为“消息代理”（Broker），可以是一个应用程序或一台设备。它是位于消息发布者和订阅者之间，它可以：</p><p>（1）接受来自客户的网络连接；</p><p>（2）接受客户发布的应用信息；</p><p>（3）处理来自客户端的订阅和退订请求；</p><p>（4）向订阅的客户转发应用程序消息。</p><h2 id="4-5-MQTT协议中的订阅、主题、会话"><a href="#4-5-MQTT协议中的订阅、主题、会话" class="headerlink" title="4.5 MQTT协议中的订阅、主题、会话"></a>4.5 MQTT协议中的订阅、主题、会话</h2><p>一、订阅（Subscription）</p><p> 订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每一个会话中的每个订阅都有一个不同的主题筛选器。</p><p>二、会话（Session）</p><p> 每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。</p><p>三、主题名（Topic Name）</p><p> 连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。</p><p>四、主题筛选器（Topic Filter）</p><p> 一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。</p><p>五、负载（Payload）</p><p> 消息订阅者所具体接收的内容。</p><h2 id="4-6-MQTT协议中的方法"><a href="#4-6-MQTT协议中的方法" class="headerlink" title="4.6 MQTT协议中的方法"></a>4.6 MQTT协议中的方法</h2><p> MQTT协议中定义了一些方法（也被称为动作），来于表示对确定资源所进行操作。这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现。通常来说，资源指服务器上的文件或输出。主要方法有：</p><p>（1）Connect。等待与服务器建立连接。</p><p>（2）Disconnect。等待MQTT客户端完成所做的工作，并与服务器断开TCP/IP会话。</p><p>（3）Subscribe。等待完成订阅。</p><p>（4）UnSubscribe。等待服务器取消客户端的一个或多个topics订阅。</p><p>（5）Publish。MQTT客户端发送消息请求，发送完成后返回应用程序线程。</p><h1 id="五、MQTT协议数据包结构"><a href="#五、MQTT协议数据包结构" class="headerlink" title="五、MQTT协议数据包结构"></a>五、MQTT协议数据包结构</h1><p> 在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Variable header）、消息体（payload）三部分构成。MQTT数据包结构如下：</p><p>（1）固定头（Fixed header）。存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识。</p><p>（2）可变头（Variable header）。存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容。</p><p>（3）消息体（Payload）。存在于部分MQTT数据包中，表示客户端收到的具体内容。</p><h2 id="5-1-MQTT固定头"><a href="#5-1-MQTT固定头" class="headerlink" title="5.1 MQTT固定头"></a>5.1 MQTT固定头</h2><p>固定头存在于所有MQTT数据包中，其结构如下：</p><h3 id="5-1-1-MQTT数据包类型"><a href="#5-1-1-MQTT数据包类型" class="headerlink" title="5.1.1 MQTT数据包类型"></a>5.1.1 MQTT数据包类型</h3><p>位置：Byte 1中bits 7-4。</p><p>相于一个4位的无符号值，类型、取值及描述如下：</p><h3 id="5-1-2-标识位"><a href="#5-1-2-标识位" class="headerlink" title="5.1.2 标识位"></a>5.1.2 标识位</h3><p>位置：Byte 1中bits 3-0。</p><p> 在不使用标识位的消息类型中，标识位被作为保留位。如果收到无效的标志时，接收端必须关闭网络连接：</p><p>（1）DUP：发布消息的副本。用来在保证消息的可靠传输，如果设置为1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送。</p><p>（2）QoS：发布消息的服务质量，即：保证消息传递的次数</p><p><img src="/img/content/mqtt/2.png" srcset="/img/loading.gif" alt=""></p><p>（3）RETAIN： 发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放。</p><h3 id="5-1-3-剩余长度（Remaining-Length）"><a href="#5-1-3-剩余长度（Remaining-Length）" class="headerlink" title="5.1.3 剩余长度（Remaining Length）"></a>5.1.3 剩余长度（Remaining Length）</h3><p>地址：Byte 2。</p><p> 固定头的第二字节用来保存变长头部和消息体的总大小的，但不是直接保存的。这一字节是可以扩展，其保存机制，前7位用于保存长度，后一部用做标识。当最后一位为1时，表示长度不足，需要使用二个字节继续保存。例如：计算出后面的大小为0</p><h2 id="5-2-MQTT可变头"><a href="#5-2-MQTT可变头" class="headerlink" title="5.2 MQTT可变头"></a>5.2 MQTT可变头</h2><p> MQTT数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是作为包的标识：</p><p> 很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有：PUBLISH (QoS &gt; 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK。</p><h2 id="5-3-Payload消息体"><a href="#5-3-Payload消息体" class="headerlink" title="5.3 Payload消息体"></a>5.3 Payload消息体</h2><p> Payload消息体位MQTT数据包的第三部分，包含CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息：</p><p>（1）CONNECT，消息体内容主要是：客户端的ClientID、订阅的Topic、Message以及用户名和密码。</p><p>（2）SUBSCRIBE，消息体内容是一系列的要订阅的主题以及QoS。</p><p>（3）SUBACK，消息体内容是服务器对于SUBSCRIBE所申请的主题及QoS进行确认和回复。</p><p>（4）UNSUBSCRIBE，消息体内容是要订阅的主题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mqtt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Email Slack WeChat预警配置</title>
    <link href="/2020/02/13/Email-Slack-WeChat%E9%A2%84%E8%AD%A6%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/02/13/Email-Slack-WeChat%E9%A2%84%E8%AD%A6%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="更新中…"><a href="#更新中…" class="headerlink" title="更新中…"></a>更新中…</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>服务器定时器配置</title>
    <link href="/2020/02/13/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/02/13/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="更新中…"><a href="#更新中…" class="headerlink" title="更新中…"></a>更新中…</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows Server部署项目</title>
    <link href="/2020/02/13/Windows-Server%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"/>
    <url>/2020/02/13/Windows-Server%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="更新中…"><a href="#更新中…" class="headerlink" title="更新中…"></a>更新中…</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux Server部署项目</title>
    <link href="/2020/02/13/Linux-Server%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"/>
    <url>/2020/02/13/Linux-Server%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="更新中…"><a href="#更新中…" class="headerlink" title="更新中…"></a>更新中…</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Django配置远程动态数据库(基于Microsoft SQL Server)</title>
    <link href="/2020/02/13/Django%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%9F%BA%E4%BA%8EMicrosoft-SQL-Server/"/>
    <url>/2020/02/13/Django%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%9F%BA%E4%BA%8EMicrosoft-SQL-Server/</url>
    
    <content type="html"><![CDATA[<h2 id="更新中…"><a href="#更新中…" class="headerlink" title="更新中…"></a>更新中…</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Django进阶</title>
    <link href="/2020/02/13/Django%E8%BF%9B%E9%98%B6/"/>
    <url>/2020/02/13/Django%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="更新中…"><a href="#更新中…" class="headerlink" title="更新中…"></a>更新中…</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Sphinx(斯芬克斯)文档概述</title>
    <link href="/2020/02/13/Sphinx-%E6%96%AF%E8%8A%AC%E5%85%8B%E6%96%AF-%E6%96%87%E6%A1%A3%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/02/13/Sphinx-%E6%96%AF%E8%8A%AC%E5%85%8B%E6%96%AF-%E6%96%87%E6%A1%A3%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="更新中…"><a href="#更新中…" class="headerlink" title="更新中…"></a>更新中…</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Markdown语法概述</title>
    <link href="/2020/02/13/markdown%E8%AF%AD%E6%B3%95%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/02/13/markdown%E8%AF%AD%E6%B3%95%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="更新中…"><a href="#更新中…" class="headerlink" title="更新中…"></a>更新中…</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用python操作excel表格</title>
    <link href="/2020/02/13/%E4%BD%BF%E7%94%A8python%E6%93%8D%E4%BD%9Cexcel%E8%A1%A8%E6%A0%BC/"/>
    <url>/2020/02/13/%E4%BD%BF%E7%94%A8python%E6%93%8D%E4%BD%9Cexcel%E8%A1%A8%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="一-python中与excel操作相关的模块"><a href="#一-python中与excel操作相关的模块" class="headerlink" title="一 python中与excel操作相关的模块"></a>一 python中与excel操作相关的模块</h1><blockquote><p>xlrd库：从excel中读取数据，支持xls、xlsx<br>xlwt库：对excel进行修改操作，不支持对xlsx格式的修改<br>xlutils库：在xlw和xlrd中，对一个已存在的文件进行修改。<br>openpyxl：主要针对xlsx格式的excel进行读取和编辑。</p></blockquote><p><strong>这里介绍openxl相关语法</strong><br>官方介绍： <a href="https://openpyxl.readthedocs.io/en/stable/" target="_blank" rel="noopener">https://openpyxl.readthedocs.io/en/stable/</a><br>安装方式：pip install openpyxl</p><p>Excel中的三大对象:</p><ul><li>WorkBook：工作簿对象</li><li>Sheet：表单对象</li><li>Cell：表格对象</li></ul><h1 id="二-openpyxl对Excel的操作"><a href="#二-openpyxl对Excel的操作" class="headerlink" title="二 openpyxl对Excel的操作"></a>二 openpyxl对Excel的操作</h1><ul><li>创建一个工作薄：wb = openpyxl.Workbook()</li><li>新增一个sheet表单：wb.create_sheet(‘test_case’)</li><li>保存case.xlsx文件：wb.save(‘cases.xlsx’)</li><li>打开工作簿：wb = openpyxl.load_workbook(‘cases.xlsx’)</li><li>选取表单：sh = wb[‘Sheet1’</li><li>读取第一行、第一列的数据：ce = sh.cell(row = 1,column = 1)</li><li>按行读取数据：row_data = list(sh.rows)</li><li>关闭工作薄：wb.close()</li><li>按列读取数据：columns_data = list(sh.columns)</li><li>写入数据之前，该文件一定要处于关闭状态</li><li>写入第一行、第四列的数据 value = ‘result’：sh.cell(row = 1,column = 4,value = ‘result’)</li><li>获取最大行总数、最大列总数：sh.max_row、sh.max_column</li><li>del 删除表单的用法：del wb[‘sheet_name’]</li><li>remove 删除表单的用法：sh = wb[‘sheet_name’] wb.remove(sh)</li></ul><pre><code class="python">import openpyxl# 创建一个工作簿wb = openpyxl.Workbook()# 创建一个test_case的sheet表单wb.create_sheet(&#39;test_case&#39;)# 保存为一个xlsx格式的文件wb.save(&#39;cases.xlsx&#39;)# 读取excel中的数据# 第一步：打开工作簿wb = openpyxl.load_workbook(&#39;cases.xlsx&#39;)# 第二步：选取表单sh = wb[&#39;Sheet1&#39;]# 第三步：读取数据# 参数 row:行  column：列ce = sh.cell(row = 1,column = 1)   # 读取第一行，第一列的数据print(ce.value)# 按行读取数据 list(sh.rows)print(list(sh.rows)[1:])     # 按行读取数据，去掉第一行的表头信息数据for cases in list(sh.rows)[1:]:    case_id =  cases[0].value    case_excepted = cases[1].value    case_data = cases[2].value    print(case_excepted,case_data)# 关闭工作薄wb.close()</code></pre><h1 id="三-封装一个读取用例的excel类：用来实现读取数据和写入数据的功能"><a href="#三-封装一个读取用例的excel类：用来实现读取数据和写入数据的功能" class="headerlink" title="三 封装一个读取用例的excel类：用来实现读取数据和写入数据的功能"></a>三 封装一个读取用例的excel类：用来实现读取数据和写入数据的功能</h1><p>cases.xlsx的测试数据：</p><h2 id="3-1-按行读取数据，存储在列表中"><a href="#3-1-按行读取数据，存储在列表中" class="headerlink" title="3.1 按行读取数据，存储在列表中"></a>3.1 按行读取数据，存储在列表中</h2><pre><code class="python">import openpyxlclass Case: #这个类用来存储用例的    __slots__ = [] #特殊的类属性，可以用来限制这个类创建的实例属性添加 可写可不写    passclass ReadExcel(object): #读取excel数据的类    def __init__(self,file_name,sheet_name):        &quot;&quot;&quot;        这个是用来初始化读取对象的        :param file_name: 文件名 ---&gt; str类型        :param sheet_name: 表单名 ———&gt; str类型        &quot;&quot;&quot;        # 打开文件        self.wb = openpyxl.load_workbook(file_name)        # 选择表单        self.sh = self.wb[sheet_name]    def read_data_line(self):        #按行读取数据转化为列表        rows_data = list(self.sh.rows)        # print(rows_data)        # 获取表单的表头信息        titles = []        for title in rows_data[0]:            titles.append(title.value)        # print(titles)        #定义一个空列表用来存储测试用例        cases = []        for case in rows_data[1:]:            # print(case)            data = []            for cell in case: #获取一条测试用例数据                # print(cell.value)                data.append(cell.value)                # print(data)                #判断该单元格是否为字符串，如果是字符串类型则需要使用eval();如果不是字符串类型则不需要使用eval()                if isinstance(cell.value,str):                    data.append(eval(cell.value))                else:                    data.append(cell.value)                #将该条数据存放至cases中            # print(dict(list(zip(titles,data))))                case_data = dict(list(zip(titles,data)))                cases.append(case_data)        return casesif __name__ == &#39;__main__&#39;:    r = ReadExcel(&#39;cases.xlsx&#39;,&#39;Sheet1&#39;)    data1 = r.read_data_line()    print(data1)</code></pre><h2 id="3-2-按行读取数据，存储在对象中"><a href="#3-2-按行读取数据，存储在对象中" class="headerlink" title="3.2 按行读取数据，存储在对象中"></a>3.2 按行读取数据，存储在对象中</h2><pre><code class="python">import openpyxlclass Case:    passclass ReadExcel(object):    def __init__(self,filename,sheetname):        self.wb = openpyxl.load_workbook(filename)        self.sh = self.wb[sheetname]    def read_data_obj(self):        &quot;&quot;&quot;        按行读取数据  每条用例存储在一个对象中        :return:        &quot;&quot;&quot;        rows_data = list(self.sh.rows)        # print(rows_data)        # 获取表单的表头信息        titles = []        for title in rows_data[0]:            titles.append(title.value)        # print(titles)        # 定义一个空列表用来存储测试用例        cases = []        for case in rows_data[1:]:            # print(case)            #创建一个Case类的对象，用来保存用例数据            case_obj = Case()            data = []            for cell in case:  # 获取一条测试用例数据                # print(cell.value)                # data.append(cell.value)                # print(data)                if isinstance(cell.value,str):  # 判断该单元格是否为字符串，如果是字符串类型则需要使用eval();如果不是字符串类型则不需要使用eval()                    data.append(eval(cell.value))                else:                    data.append(cell.value)            # 将该条数据存放至cases中            # print(dict(list(zip(titles,data))))            case_data = list(zip(titles, data))            # print(case_data)            for i in case_data:                setattr(case_obj,i[0],i[1])            # print(case_obj)            # print(case_obj.case_id,case_obj.data,case_obj.excepted)            cases.append(case_obj)        return casesif  __name__ == &#39;__main__&#39;:    r = ReadExcel(&#39;cases.xlsx&#39;,&#39;Sheet1&#39;)    res = r.read_data_obj()    for i in res:        print(i.caseid, i.excepted, i.data)</code></pre><h2 id="3-3-将测试用例封装到列表中，读取指定列的数据"><a href="#3-3-将测试用例封装到列表中，读取指定列的数据" class="headerlink" title="3.3 将测试用例封装到列表中，读取指定列的数据"></a>3.3 将测试用例封装到列表中，读取指定列的数据</h2><pre><code class="python">import openpyxlclass Case:    passclass ReadExcelZy(object):    def __init__(self,filename,sheetname):        self.wb = openpyxl.load_workbook(filename)        self.sheet = self.wb[sheetname]        # list1 参数为一个列表，传入的是指定读取数据的列,比如[1,2,3]        # 每一行[1,3,5]列的数据，读取出来就作为一条测试用例，放在字典中        # 所有的用例放在列表中并且进行返回    def read_data(self,list1):        &quot;&quot;&quot;        :param list1:  list---&gt;要读取列   list类型        :return:    返回一个列表，每一个元素为一个用例（用例为dict类型）        &quot;&quot;&quot;        # 获取最大的行数        max_r = self.sheet.max_row        cases = []   #定义一个空列表，用来存放所有的用例数据        titles = []   #定义一个空列表，用来存放表头        # 遍历所有的行数据        for row in range(1,max_r+1):            if row != 1:      #判断是否是第一行                case_data = [] #定义一个空列表，用来存放该行的用例数据                for column in list1:                    info = self.sheet.cell(row,column).value                    # print(info)                    case_data.append(info)                    # print(list(zip(titles,case_data)))                case = dict(zip(titles,case_data))  #将该条数据和表头进行打包组合,作用相当于dict(list(zip(titles,case_data)))                # print(case)                cases.append(case)                # print(cases)            else:   #获取表头数据                for column in list1:                    title = self.sheet.cell(row,column).value                    titles.append(title)                # print(titles)        return casesif __name__ == &#39;__main__&#39;:    r = ReadExcelZy(&quot;cases.xlsx&quot;,&quot;Sheet1&quot;)    res = r.read_data([1,2,3])    for o in res:        print(o[&#39;caseid&#39;],o[&#39;data&#39;],o[&#39;excepted&#39;])</code></pre><h2 id="3-4-将测试用例封装到对象中，读取指定列的数据"><a href="#3-4-将测试用例封装到对象中，读取指定列的数据" class="headerlink" title="3.4 将测试用例封装到对象中，读取指定列的数据"></a>3.4 将测试用例封装到对象中，读取指定列的数据</h2><pre><code class="python">import openpyxlclass Case:    passclass ReadExcelZy(object):    def __init__(self,filename,sheetname):        self.wb = openpyxl.load_workbook(filename)        self.sheet = self.wb[sheetname]        # list1 参数为一个列表，传入的是指定读取数据的列,比如[1,2,3]        # 每一行[1,3,5]列的数据，读取出来就作为一条测试用例，放在字典中        # 所有的用例放在对象中并且进行返回    def read_data_obj(self,list2):        max_r1 = self.sheet.max_row      #获取最大行数        cases = []        titles = []      #用来存放表头数据        for row in range(1,max_r1+1):            if row != 1:                case_data = []                for column in list2:                    info = self.sheet.cell(row,column).value                    # print(info)                    case_data.append(info)                cases_data = list(zip(titles,case_data))                #将一条用例存到一个对象中（每一列对应对象的一个属性）                case_obj = Case()                for i in cases_data:                    # print(i)                    setattr(case_obj,i[0],i[1])                # print(case_obj.caseid,case_obj.excepted,case_obj.data)                cases.append(case_obj)            else:                for column in list2:                    title = self.sheet.cell(row,column).value                    titles.append(title)        return casesif __name__ == &#39;__main__&#39;:    r = ReadExcelZy(&quot;cases.xlsx&quot;,&quot;Sheet1&quot;)    res = r.read_data_obj([1,2,3])    for i in res:        print(i.caseid,i.data,i.excepted)</code></pre><h2 id="3-5-优化第4部分代码，将设置对象属性写在初始化方法中-封装Excel类读取数据最常用的方法"><a href="#3-5-优化第4部分代码，将设置对象属性写在初始化方法中-封装Excel类读取数据最常用的方法" class="headerlink" title="3.5 优化第4部分代码，将设置对象属性写在初始化方法中(封装Excel类读取数据最常用的方法)"></a>3.5 优化第4部分代码，将设置对象属性写在初始化方法中(封装Excel类读取数据最常用的方法)</h2><pre><code class="python">import openpyxlclass Case:  # 这个类用来存储用例的    def __init__(self, attrs):        &quot;&quot;&quot;        初始化用例        :param attrs:zip类型——&gt;[{key,value},(key1,value1)......]        &quot;&quot;&quot;        for i in attrs:            setattr(self, i[0], i[1])class ReadExcel(object):    def __init__(self, filename, sheetname):        &quot;&quot;&quot;        定义需要打开的文件及表名        :param filename:   文件名        :param sheetname:  表名        &quot;&quot;&quot;        self.wb = openpyxl.load_workbook(filename)        self.sheet = self.wb[sheetname]    def read_data_obj_new(self, list2):        # 获取最大行数        max_r1 = self.sheet.max_row        cases = []        # 用来存放表头数据        titles = []        for row in range(1, max_r1 + 1):            if row != 1:                case_data = []                for column in list2:                    info = self.sheet.cell(row, column).value                    # print(info)                    case_data.append(info)                case = list(zip(titles, case_data))                # 新建对象时，将对象传给Case类                case_obj = Case(case)                # print(case_obj.caseid,case_obj.excepted,case_obj.data)                cases.append(case_obj)            else:                # 获取表头                for column in list2:                    title = self.sheet.cell(row, column).value                    titles.append(title)                if None in titles:                    raise ValueError(&quot;传入的表头的数据有显示为空&quot;)        return casesif __name__ == &#39;__main__&#39;:    r = ReadExcel(&#39;cases.xlsx&#39;, &#39;Sheet1&#39;)    res1 = r.read_data_obj_new([1, 2, 3])    for i in res1:        print(i.caseid, i.data, i.excepted)</code></pre><h1 id="四-完整流程的代码"><a href="#四-完整流程的代码" class="headerlink" title="四 完整流程的代码"></a>四 完整流程的代码</h1><h2 id="4-1-将测试数据参数化"><a href="#4-1-将测试数据参数化" class="headerlink" title="4.1 将测试数据参数化"></a>4.1 将测试数据参数化</h2><pre><code class="python">import unittestfrom python.register_new.register import registerfrom python.register_new.register_testcase_new import RegisterTestCasefrom HTMLTestRunnerNew import HTMLTestRunnerclass RegisterTestCase(unittest.TestCase):    # 初始化测试用例    def __init__(self,modethod_name,excepted,data):         # modethod_name 测试用例方法名        super().__init__(modethod_name)        # excepted 测试用例的预期结果        self.excepted = excepted        # data 测试用例参数值                        self.data = data    def setUp(self):        print(&quot;准备测试环境，执行测试用例之前会执行此操作&quot;)    def tearDown(self):        print(&quot;还原测试环境，执行完测试用例之后会执行此操作&quot;)    def test_register(self):        res = register(*self.data)        try:            self.assertEquals(self.excepted,res)        except AssertionError as e:            print(&quot;该条测试用例执行未通通过&quot;)            raise e        else:            print(&quot;该条测试用例执行通过&quot;)  # 创建测试套件suite = unittest.TestSuite()# 将测试用例添加至测试套件中case = [{&#39;excepted&#39;:&#39;{&quot;code&quot;: 1, &quot;msg&quot;: &quot;注册成功&quot;}&#39;,&#39;data&#39;:&#39;(&#39;python1&#39;, &#39;123456&#39;,&#39;123456&#39;)&#39;},        {&#39;excepted&#39;:&#39;{&quot;code&quot;: 0, &quot;msg&quot;: &quot;两次密码不一致&quot;}&#39;,&#39;data&#39;:&#39;(&#39;python1&#39;, &#39;1234567&#39;,&#39;123456&#39;)&#39;}]for case in cases:    suite.addTest(RegisterTestCase(&#39;test_register&#39;,case[&#39;excepted&#39;],case[&#39;data&#39;]))# 执行测试套件，生成测试报告with open(&quot;report.html&quot;,&#39;wb&#39;) as f:    runner = HTMLTestRunner(        stream = f,        verbosity = 2,        title = &#39;python_test_report&#39;,        description = &#39;这是一份测试报告&#39;,        tester = &#39;WL&#39;    )    runner.run(suite)</code></pre><h2 id="4-2-将调用封装好的Excel类的完整代码流程"><a href="#4-2-将调用封装好的Excel类的完整代码流程" class="headerlink" title="4.2 将调用封装好的Excel类的完整代码流程"></a>4.2 将调用封装好的Excel类的完整代码流程</h2><pre><code class="python">import unittestfrom python.register_new.register import registerfrom python.register_new.register_testcase_new import RegisterTestCasefrom HTMLTestRunnerNew import HTMLTestRunnerfrom python.readexcel import ReadExcelclass RegisterTestCase(unittest.TestCase):    # 初始化测试用例    def __init__(self, modethod_name, excepted, data):        # modethod_name 测试用例方法名        super().__init__(modethod_name)        # excepted 测试用例的预期结果        self.excepted = excepted        # data 测试用例参数值        self.data = data    def setUp(self):        print(&quot;准备测试环境，执行测试用例之前会执行此操作&quot;)    def tearDown(self):        print(&quot;还原测试环境，执行完测试用例之后会执行此操作&quot;)    def test_register(self):        res = register(*self.data)        try:            self.assertEquals(self.excepted, res)        except AssertionError as e:            print(&quot;该条测试用例执行未通通过&quot;)            raise e        else:            print(&quot;该条测试用例执行通过&quot;)# 创建测试套件suite = unittest.TestSuite()# 调用封装好的读取数据的Excel类，获取测试数据r1 = ReadExcel(&#39;cases.xlsx&#39;, &#39;Sheet1&#39;)cases = r1.read_data_obj_new([2, 3])# 将测试用例添加至测试套件中for case in cases:    # 需要使用eva()函数对except和data进行自动识别    suite.addTest(RegisterTestCase(&#39;test_register&#39;, eval(case.excepted), eval(case.data)))# 执行测试套件，生成测试报告with open(&quot;report.html&quot;, &#39;wb&#39;) as f:    runner = HTMLTestRunner(        stream=f,        verbosity=2,        title=&#39;python_test_report&#39;,        description=&#39;这是一份测试报告&#39;,        tester=&#39;WL&#39;)    runner.run(suite)</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python进阶</title>
    <link href="/2020/02/13/python%E8%BF%9B%E9%98%B6/"/>
    <url>/2020/02/13/python%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="数据容器"><a href="#数据容器" class="headerlink" title="数据容器"></a>数据容器</h1><p><strong>List</strong><br><strong>迭代</strong></p><pre><code class="python">li = [&#39;umaru&#39;, &#39;ebina&#39;, &#39;tachibana&#39;]for e in li:    print(li)# umaru ebina tachibana</code></pre><p><strong>同时迭代元素与其索引</strong><br>用 enumerate 即可</p><pre><code class="python">li = [&#39;umaru&#39;, &#39;ebina&#39;, &#39;tachibana&#39;]print([f&#39;{i+1}. {elem}&#39; for i, elem in enumerate(li)])# [&#39;1. umaru&#39;, &#39;2. ebina&#39;, &#39;3. tachibana&#39;]</code></pre><p><strong>同时迭代 2 个以上的 iterable</strong><br>用 zip 即可</p><pre><code class="python">subjects = (&#39;nino&#39;, &#39;miku&#39;, &#39;itsuki&#39;)predicates = (&#39;saikou&#39;, &#39;ore no yome&#39;, &#39;is sky&#39;)print([f&#39;{s} {p}&#39; for s, p in zip(subjects, predicates)])# [&#39;nino saikou&#39;, &#39;miku ore no yome&#39;, &#39;itsuki is sky&#39;]</code></pre><p><strong>iterable 解包</strong><br>最典型的例子就是 2 数交换</p><pre><code class="python">a, b = b, a# 等价于 a, b = (b, a)</code></pre><p>用星号运算符解包可以获取剩余的元素</p><pre><code class="python">first, *rest = [1, 2, 3, 4]first# 1rest# [2, 3, 4]</code></pre><p>用下划线可以忽略某个变量</p><pre><code class="python">filename, _ = &#39;eroge.exe&#39;.split(&#39;.&#39;)filename# &#39;eroge&#39;</code></pre><p><strong>Dict</strong><br><strong>迭代</strong></p><pre><code class="python">d = {&#39;name&#39;: &#39;sekiro&#39;, &#39;hobby&#39;: &#39;blacksmithing&#39;, &#39;tendency&#39;: &#39;death&#39;}[key for key in d.keys()]# [&#39;name&#39;, &#39;hobby&#39;, &#39;tendency&#39;][value for value in d.values()]# [&#39;sekiro&#39;, &#39;blacksmithing&#39;, &#39;death&#39;][f&#39;{key}: {value}&#39; for key, value in d.items()]# [&#39;name: sekiro&#39;, &#39;hobby: blacksmithing&#39;, &#39;tendency: death&#39;]</code></pre><p><strong>缺失键处理</strong><br>get 返回键值，如果键不在字典中，将会返回 None ，可自行设定一个默认值</p><pre><code class="python">d = {&#39;name&#39;: &#39;okabe rintaro&#39;, &#39;motto&#39;: &#39;elpsycongroo&#39;}d.get(&#39;job&#39;, &#39;mad scientist&#39;)# mad scientist</code></pre><p>setdefault 返回键值，如果键不在字典中，将会添加它并设置一个默认值</p><pre><code class="python">d = {&#39;name&#39;: &#39;okabe rintaro&#39;, &#39;motto&#39;: &#39;elpsycongroo&#39;}d.setdefault(&#39;job&#39;, &#39;mad scientist&#39;)# mad scientistd# {&#39;name&#39;: &#39;okabe rintaro&#39;, &#39;motto&#39;: &#39;elpsycongroo&#39;, &#39;job&#39;: &#39;mad scientist&#39;}</code></pre><h1 id="语言专属特性"><a href="#语言专属特性" class="headerlink" title="语言专属特性"></a>语言专属特性</h1><p><strong>推导式</strong><br>推导式是一种快速构建可迭代对象的方法，因此凡是可迭代的对象都支持推导式</p><p><strong>列表推导式</strong><br>获取 0-10 内的所有偶数</p><pre><code class="python">even = [i for i in range(10) if not i % 2]even# [0, 2, 4, 6, 8]</code></pre><p><strong>字典推导式</strong><br>将装满元组的列表转换为字典</p><pre><code class="python">SEIREI = [(0, &#39;takamiya mio&#39;), (1, &#39;tobiichi origami&#39;), (2, &#39;honjou nia&#39;), (3, &#39;tokisaki kurumi&#39;), (4, &#39;yoshino&#39;), (5, &#39;itsuka kotori&#39;), (6, &#39;hoshimiya mukuro&#39;), (7, &#39;natsumi&#39;), (8, &#39;yamai&#39;), (9, &#39;izayoi miku&#39;), (10, &#39;yatogami tohka&#39;)]seirei_code = {seirei: code for code, seirei in SEIREI}seirei_code# {&#39;takamiya mio&#39;: 0, &#39;tobiichi origami&#39;: 1, &#39;honjou nia&#39;: 2, &#39;tokisaki kurumi&#39;: 3, &#39;yoshino&#39;: 4, &#39;itsuka kotori&#39;: 5, &#39;hoshimiya mukuro&#39;: 6, &#39;natsumi&#39;: 7, &#39;yamai&#39;: 8, &#39;izayoi miku&#39;: 9, &#39;yatogami tohka&#39;: 10}{code: seirei.upper() for seirei, code in seirei_code.items() if code &gt; 6}# {7: &#39;NATSUMI&#39;, 8: &#39;YAMAI&#39;, 9: &#39;IZAYOI MIKU&#39;, 10: &#39;YATOGAMI TOUKA&#39;}</code></pre><p><strong>合推导式</strong><br>求所有数字的平方并去除重复元素</p><pre><code class="python">{x ** 2 for x in [1, 2, 2, 3, 3]}# {1, 4, 9}</code></pre><p><strong>生成器表达式</strong><br>求 0-10 内的所有偶数的和</p><pre><code class="python">even_sum_under_10 = sum(i for i in range(11) if not i % 2)even_sum_under_10# 30</code></pre><p><strong>星号和双星号</strong></p><p><strong>数据容器的合并</strong></p><pre><code class="python">l1 = [&#39;kaguya&#39;, &#39;miyuki&#39;]l2 = [&#39;chika&#39;, &#39;ishigami&#39;][*l1, *l2]# [&#39;kaguya&#39;, &#39;miyuki&#39;, &#39;chika&#39;, &#39;ishigami&#39;]d1 = {&#39;name&#39;: &#39;rimuru&#39;}d2 = {&#39;kind&#39;: &#39;slime&#39;}{**d1, **d2}# {&#39;name&#39;: &#39;rimuru&#39;, &#39;kind&#39;: &#39;slime&#39;}</code></pre><p><strong>函数参数的打包与解包</strong></p><pre><code class="python"># 打包def foo(*args):    print(args)foo(1, 2)# (1, 2)def bar(**kwargs):    print(kwargs)bar(name=&#39;hayasaka&#39;, job=&#39;maid&#39;)# {&#39;name&#39;: &#39;hayasaka&#39;, &#39;job&#39;: &#39;maid&#39;}# 解包t = (10, 3)quotient, remainder = divmod(*t)quotient# 商：3remainder# 余：1</code></pre><p><strong>装饰器</strong><br>装饰器是一个可调用的对象，顾名思义它能够装饰在某个可调用的对象上，给它增加额外的功能</p><p>常用于缓存、权限校验、日志记录、性能测试、事务处理等场景</p><p>以下实现了一个简单的日志装饰器，能打印出函数的执行时间、函数名、函数参数和执行结果</p><pre><code class="python">import timefrom functools import wrapsdef clock(func):    @wraps(func) # 防止被装饰函数的属性被wrapper覆盖    def wrapper(*args, **kwargs):        t0 = time.perf_counter()        result = func(*args, **kwargs) # 由于闭包，wrapper函数包含了自由变量func        elapsed = time.perf_counter() - t0        name = func.__name__        args = &#39;, &#39;.join(repr(arg) for arg in args)        kwargs = &#39;, &#39;.join(f&#39;{k}={w}&#39; for k, w in sorted(kwargs.items()))        all_args_str = &#39;, &#39;.join(astr for astr in [args_str, kwargs_str] if astr)        print(f&#39;[{elapsed:.8f}s] {name}({all_args_str}) -&gt; {result}&#39;)        return result    return wrapper # 返回内部函数，取代被装饰的函数@clockdef factorial(n: int) -&gt; int:    return 1 if n &lt; 2 else n * factorial(n-1)factorial(5)# [0.00000044s] factorial(1) -&gt; 1# [0.00011111s] factorial(2) -&gt; 2# [0.00022622s] factorial(3) -&gt; 6# [0.00030844s] factorial(4) -&gt; 24# [0.00042222s] factorial(5) -&gt; 120# 120</code></pre><p>如果想让装饰器能接受参数，那就要再嵌套一层</p><pre><code class="python">import timefrom functools import wrapsDEFAULT_FMT = &#39;[{elapsed:.8f}s] {name}({all_args_str}) -&gt; {result}&#39;def clock(fmt=DEFAULT_FMT):    def decorate(func):        @wraps(func)        def wrapper(*args, **kwargs):            t0 = time.perf_counter()            result = func(*args, **kwargs)            elapsed = time.perf_counter() - t0            name = func.__name__            args_str = &#39;, &#39;.join(repr(arg) for arg in args)            kwargs_str = &#39;, &#39;.join(f&#39;{k}={w}&#39; for k, w in sorted(kwargs.items()))            all_args_str = &#39;, &#39;.join(astr for astr in [args_str, kwargs_str] if astr)            print(fmt.format(**locals()))            return result        return wrapper    return decorate@clock()def factorial_default_fmt(n: int) -&gt; int:    return 1 if n &lt; 2 else n * factorial_default_fmt(n-1)@clock(&#39;{name}: {elapsed}s&#39;)def factorial_customed_fmt(n: int) -&gt; int:    return 1 if n &lt; 2 else n * factorial_customed_fmt(n-1)factorial_default_fmt(3)# [0.00000044s] factorial_default_fmt(1) -&gt; 1# [0.00009600s] factorial_default_fmt(2) -&gt; 2# [0.00018133s] factorial_default_fmt(3) -&gt; 6# 6factorial_customed_fmt(3)# factorial_customed_fmt: 4.444450496521313e-07s# factorial_customed_fmt: 9.733346314533264e-05s# factorial_customed_fmt: 0.0001831113553407704s# 6</code></pre><p>在 django 中，可以通过装饰器对函数视图进行功能增强（比如@login_required 进行登录的权限校验，@cache_page 进行视图的缓存等）</p><p><strong>上下文管理器</strong><br>用于资源的获取与释放，以代替 try-except 语句</p><p>常用于文件 IO，锁的获取与释放，数据库的连接与断开等</p><pre><code class="python"># try:#     f = open(input_path)#     data = f.read()# finally:#     f.close()with open(input_path) as f:    data = f.read()</code></pre><p>其实在 pathlib 里已经给我们封装好了文件 IO 方法</p><pre><code class="python"># with open(&#39;file&#39;) as i:#     data = i.read()from pathlib import Pathdata = Path(&#39;file&#39;).read_text()</code></pre><p>至于上下文管理器的实现，可以用@contextmanager</p><pre><code class="python">from contextlib import contextmanager@contextmanagerdef open_write(filename):    try:        f = open(filename, &#39;w&#39;)        yield f    finally:        f.close()with open_write(&#39;onegai.txt&#39;) as f:    f.write(&#39;Dagakotowaru!&#39;)</code></pre><p><strong>多重继承</strong></p><p>在 django 中经常要处理类的多重继承的问题，这时就要用到 super 函数</p><p>如果单单认为 super 仅仅是“调用父类的方法”，那就错了</p><p>在继承单个类的情况下，可以认为 super 是调用父类的方法（ES6 里面亦是如此）</p><p>但多重继承就不一样了，因为方法名可能会有冲突，所以 super 就不能单指父类了</p><p><strong>在 Python 中，super 指的是 MRO 中的下一个类</strong>，用来解决多重继承时父类的查找问题</p><p>MRO 是啥？Method Resolution Order（方法解析顺序）</p><p>看完下面的例子，就会理解了</p><pre><code class="python">class A:    def __init__(self):        print(&#39;A&#39;)class B(A):    def __init__(self):        print(&#39;enter B&#39;)        super().__init__()        print(&#39;leave B&#39;)class C(A):    def __init__(self):        print(&#39;enter C&#39;)        super().__init__()        print(&#39;leave C&#39;)class D(B, C):    passd = D()# enter B# enter C# A# leave C# leave Bprint(d.__class__.__mro__)# (&lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;)</code></pre><p>首先，因为 D 继承了 B 类，所以调用 B 类的<strong>init</strong>，打印了enter B</p><p>打印enter B后的 super 寻找 MRO 中的 B 的下一个类，也就是 C 类，并调用其<strong>init</strong>，打印enter C</p><p>打印enter C后的 super 寻找 MRO 中的 C 的下一个类，也就是 A 类，并调用其<strong>init</strong>，打印A</p><p>打印A后回到 C 的<strong>init</strong>，打印leave C</p><p>打印leave C后回到 B 的<strong>init</strong>，打印leave B</p><p><strong>特殊方法</strong><br>在 django 中，定义 model 的时候，希望 admin 能显示 model 的某个字段而不是 XXX Object，那么就要定义好<strong>str</strong></p><p>每当你使用一些内置函数时，都是在调用一些特殊方法，例如 len()调用了<strong>len</strong>(), str()调用<strong>str</strong>()等</p><p>以下实现一个 2d 数学向量类，里面有多个特殊方法</p><pre><code class="python">from math import hypotclass Vector2d:    # 限制允许绑定的属性    __slots__ = (&#39;__x&#39;, &#39;__y&#39;)    # 实例创建    def __init__(self, x, y):        self.__x = float(x)        self.__y = float(y)    # 前双下划线是私有属性，property装饰是只读属性    @property    def x(self):        return self.__x    @property    def y(self):        return self.__y    # 可迭代对象    def __iter__(self):        yield from (self.x, self.y)    # 字符串表示形式    def __repr__(self) -&gt; str:        return f&#39;{type(self).__name__}({self.x}, {self.y})&#39;    # 数值转换 - 绝对值    def __abs__(self) -&gt; float:        return hypot(self.x, self.y)    # 数值转换 - 布尔值    def __bool__(self) -&gt; bool:        return bool(abs(self))    # 算术运算符 - 加    def __add__(self, other):        x = self.x + other.x        y = self.y + other.y        return Vector2d(x, y)    # 算术运算符 - 乘    def __mul__(self, scalar: float):        return Vector2d(self.x * scalar, self.y * scalar)    # 比较运算符 - 相等    def __eq__(self, other):        return tuple(self) == tuple(other)    # 可散列    def __hash__(self):        return hash(self.x) ^ hash(self.y)v = Vector2d(3, 4)# __slots__限制了允许绑定的属性，只能是x或yv.z = 1# Traceback (most recent call last):#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;# AttributeError: &#39;Vector2d&#39; object has no attribute &#39;z&#39;# 由于x属性只读，因此无法再次赋值v.x = 1# Traceback (most recent call last):#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;# AttributeError: can&#39;t set attribute# iter(v) =&gt; v.__iter__()x, y = v# x为3, y为4# repr(v) =&gt; v.__repr__()v# Vector2d(3, 4)# abs(v) =&gt; v.__abs__()abs(v)# 5.0# bool(v) =&gt; v.__bool__()bool(v)# True# v1 + v2  =&gt; v1.__add__(v2)v1 = Vector2d(1, 2)v2 = Vector2d(3, 4)v1 + v2# Vector2d(4, 6)# v * 3  =&gt; v.__mul__(3)v * 3# Vector2d(9, 12)# v1 == v2 =&gt; v1.__eq__(v2)v1 = Vector2d(1, 2)v2 = Vector2d(1, 2)v1 == v2# True# hash(v) =&gt; v.__hash__()hash(v)# 7v1 = Vector2d(1, 2)v2 = Vector2d(3, 4)set([v1, v2])# {Vector2d(1.0, 2.0), Vector2d(3.0, 4.0)}</code></pre><p>如果把 Vector 改造为多维向量呢？关键就是要实现序列协议（<strong>len</strong>和<strong>getitem</strong>）</p><p>协议：本质上是<a href="https://baike.baidu.com/item/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/10845665?fr=aladdin" target="_blank" rel="noopener">鸭子类型</a>语言使用的非正式接口</p><p>不仅如此，还要实现多分量的获取以及散列化</p><pre><code class="python">from array import arrayimport reprlibimport mathimport numbersimport stringfrom functools import reducefrom operator import xorfrom itertools import zip_longestimport numbersfrom fractions import Fraction as Fclass Vector:    typecode = &#39;d&#39;    shortcut_names = &#39;xyzt&#39;    def __init__(self, components):        self._components = array(self.typecode, components)    def __iter__(self):        return iter(self._components)    def __repr__(self):        components = reprlib.repr(self._components)        components = components[components.find(&#39;[&#39;):-1]        return f&#39;{type(self).__name__}({components})&#39;    def __str__(self):        return str(tuple(self))    def __eq__(self, other):        return tuple(self) == tuple(other)    def __bool__(self):        return bool(abs(self))    # 序列协议 - 获取长度    def __len__(self):        return len(self._components)    # 序列协议 - 索引取值    def __getitem__(self, index):        cls = type(self)  # Vector        if isinstance(index, slice):  # 索引是slice对象，则返回Vector实例            return cls(self._components[index])        elif isinstance(index, numbers.Integral):  # 索引是整数类型，则返回_components中对应的数字            return self._components[index]        else:            raise TypeError(f&#39;{cls.__name__} indices must be integers.&#39;)    # 属性访问，获取分量的值    def __getattr__(self, name):        cls = type(self)        if len(name) == 1:            pos = cls.shortcut_names.find(name)            if 0 &lt;= pos &lt; len(self._components):                return self._components[pos]        raise AttributeError(f&#39;{cls.__name__} has no attribute {name}&#39;)    # 属性设置，给分量设值时会抛出异常，使向量是不可变的    def __setattr__(self, name, value):        cls = type(self)        if len(name) == 1:            if name in string.ascii_lowercase:                raise AttributeError(f&quot;can&#39;t set attribute &#39;a&#39; to &#39;z&#39; in {cls.__name__}&quot;)        super().__setattr__(name, value)    # 比较所有分量，都相等才算两向量相等    def __eq__(self, other):        return len(self) == len(other) and all(a == b for a, b in zip(self, other))    # 散列化    def __hash__(self):        hashes = map(hash, self._components)        return reduce(xor, hashes, 0)    # 绝对值    def __abs__(self):        return math.sqrt(sum(x ** 2 for x in self))    # 取正    def __pos__(self):        return Vector(self)    # 取负    def __neg__(self):        return Vector(-x for x in self)    # 加 (减法__sub__的实现与之类似，略)    def __add__(self, other):        try:            return Vector(a + b for a, b in zip_longest(self, other, fillvalue=0.0))        except TypeError:            return NotImplemented    # 反向加（a+b中，如果a没有__add__或返回NotImplemented，则检查b是否有__radd__，有则调用之）    def __radd__(self, other):        return self + other    # 乘 (除法__truediv__的实现与之类似，略)    def __mul__(self, scalar):        return Vector(n * scalar for n in self) if isinstance(scalar, numbers.Real) else NotImplemented    # 反向乘    def __rmul__(self, scalar):        return self * scalar    # 中缀运算符@ - 点积    def __matmul__(self, other):        try:            return sum(a * b for a, b in zip(self, other))        except TypeError:            return NotImplemented    # 反向中缀运算符@    def __rmatmul__(self, other):        return self @ otherv = Vector(range(7))v# Vector([0.0, 1.0, 2.0, 3.0, 4.0, ...])v[1:3]# Vector([1.0, 2.0])v[-1]# 6.0v[1,3]# Traceback (most recent call last):#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;#   File &quot;&lt;stdin&gt;&quot;, line 39, in __getitem__# TypeError: Vector indices must be integers.v.x, v.y, v.z# (0.0, 1.0, 2.0)v.x = 1# Traceback (most recent call last):#   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;#   File &quot;&lt;stdin&gt;&quot;, line 62, in __setattr__# AttributeError: can&#39;t set attribute &#39;a&#39; to &#39;z&#39; in Vectorv1 = Vector((3, 4, 5))v2 = Vector((6, 7))v1 == v2# Falseset([v1, v2])# {Vector([6.0, 7.0]), Vector([3.0, 4.0, 5.0])}abs(v)# 9.539392014169456+v# Vector([0.0, 1.0, 2.0, 3.0, 4.0, ...])-v# Vector([-0.0, -1.0, -2.0, -3.0, -4.0, ...])v1 + v2# Vector([9.0, 11.0, 5.0])v * 3# Vector([0.0, 3.0, 6.0, 9.0, 12.0, ...])v * F(1, 2)# Vector([0.0, 0.5, 1.0, 1.5, 2.0, ...])v1 @ v2# 46.0</code></pre><p>想了解所有的特殊方法可查阅<a href="https://docs.python.org/3/reference/datamodel.html#special-method-names" target="_blank" rel="noopener">官方文档</a>,以下列举些常用的：</p><pre><code class="python">字符串表示形式：__str__, __repr__数值转换：__abs__, __bool__, __int__, __float__, __hash__集合模拟：__len__, __getitem__, __setitem__, __delitem__, __contains__迭代枚举：__iter__, __reversed__, __next__可调用模拟：__call__实例创建与销毁：__init__, __del__属性访问：__getattr__, __setattr__运算符相关：__add__, __radd__, __mul__, __rmul__, __matmul__, __rmatmul__, ...</code></pre><p><strong>类方法和静态方法</strong><br>@classmethod 是类方法，它定义操作类的方法，也就是说会将类绑定给方法，而不是实例</p><p>@staticmethod 是静态方法，啥都不绑定，一般用来给类绑定各种工具方法（不涉及对实例和类的操作）</p><p>在 django 中，我们经常要在视图函数中对模型类进行各种查询</p><p>然而，很多查询都是重复的代码，根据 DRY 原则，它们都是可以被封装的</p><p>那么，如果我们要给模型类封装一些查询操作，就要用到@classmethod</p><p>以下是 Post 类，里面定义了 latest_posts 方法用来获取最新的几个 Post</p><p>这样在视图函数中，就能直接调用该方法进行查询，节省了不少代码</p><pre><code class="python">class Post(models.Model):    STATUS_NORMAL = 1    STATUS_DELETE = 0    STATUS_DRAFT = 2    STATUS_ITEMS = (        (STATUS_NORMAL, &#39;正常&#39;),        (STATUS_DELETE, &#39;删除&#39;),        (STATUS_DRAFT, &#39;草稿&#39;),    )    ...    status = models.PositiveIntegerField(_(&quot;状态&quot;), choices=STATUS_ITEMS, default=STATUS_NORMAL)    created_time = models.DateTimeField(_(&quot;创建时间&quot;), auto_now_add=True)    ...    @classmethod    def latest_posts(cls, limit=None):        queryset = cls.objects.filter(status=cls.STATUS_NORMAL).order_by(&#39;-created_time&#39;)        if limit:            queryset = queryset[:limit]        return queryset</code></pre><p><strong>描述符</strong><br>实现了<strong>set</strong>或<strong>get</strong>协议的类就是描述符</p><p>set 和 get 代表存和取，因此描述符是一种对多个类属性运用相同存取逻辑的一种方式</p><p>例如 django 的 ORM 中的字段类型是描述符，用来把数据库记录中的字段数据与 Python 对象的属性对应起来</p><p>以下实现一个简单的描述符类，用来在读写属性时验证属性的正确性</p><pre><code class="python">class Validator:    def __init__(self, storage_name):        self.storage_name = storage_name    def __set__(self, instance, value):        if not isinstance(value, int):            raise ValueError(&#39;Value must be an integer&#39;)        if value &gt; 200:            raise ValueError(&#39;Value must be under 200&#39;)class Person:    age = Validator(&#39;age&#39;)    def __init__(self, age):        self.age = ageperson = Person(age=100)person.age = &#39;young&#39;# Traceback (most recent call last):# ValueError: Value must be an integerperson.age = 201# Traceback (most recent call last):# ValueError: Value must be under 200</code></pre><p><strong>元类</strong></p><p>进入元类这个概念之前，我们先回顾一下 type()这个函数，不，其实它是个类</p><p>通过 type()，我们可以获取一个对象所属的类，但通过 help 函数，发现 type()居然也可以用来创建类！</p><pre><code class="python">type(name, bases, dict) -&gt; a new type</code></pre><p>name 是新类的名称，bases 是继承的子类，dict 则是新类的属性名与其对应值的字典</p><pre><code class="python">class A:    a = 1    def foo(self):        return self.a * 2# 以上类的创建等价于A = type(&#39;A&#39;, (object, ), {&#39;a&#39;: 1, &#39;foo&#39;: lambda self: self.a * 2})</code></pre><p>那么什么是元类呢？</p><p>平时我们用类来创建对象，但一切类都继承了对象，说白了类也是对象，而元类就是用来创建类对象的类</p><p>说白了，元类就是制造类的工厂</p><pre><code class="python">&#39;alphardex&#39;.__class__# &lt;class &#39;str&#39;&gt;&#39;alphardex&#39;.__class__.__class__# &lt;class &#39;type&#39;&gt;</code></pre><p>通过以上的例子我们知道 type 就是用来创造一切类的元类，它是 Python 内置的元类</p><p>既然有内置的元类，也意味着你也可以自定义元类</p><p>以下实现一个元类，用来把类的所有非私有属性自动转换为大写（不已_开头的属性都是非私有的）</p><p>思路很简单：把属性和对应的值字典(attrs)里的非私有属性键改为大写(upper)就行了</p><pre><code class="python">class UpperAttrMeta(type):    def __new__(cls, name, bases, attrs):        &quot;&quot;&quot;        __init__方法用来初始化对象并传入参数        而__new__方法专门用来创建对象（显然这里我们要创建一个类对象并定制它）        &quot;&quot;&quot;        upper_attrs = {k.upper() if not k.startswith(&#39;_&#39;) else k: v for k, v in attrs.items()}        return super().__new__(cls, name, bases, upper_attrs)class Foo(metaclass=UpperAttrMeta):    name = &#39;alphardex&#39;    __love = &#39;unknown&#39;f = Foo()f.NAME# &#39;alphardex&#39;f._Foo__love# &#39;unknown&#39;</code></pre><p>元类的最经典的用途就是 ORM 的实现，以 django 的 ORM 为例</p><pre><code class="python">class Person(models.Model):    name = models.CharField(max_length=30)    age = models.IntegerField()p = Person(name=&#39;alphardex&#39;, age=&#39;24&#39;)p.age# 24</code></pre><p>如果你访问一个模型实例的属性（例如这里的 age），你并不会得到什么 IntegerField()，而是得到了 24 这个数字，这就是元类的作用</p><p>元类平时很少用到，如果要动态修改类的属性，可以用猴子补丁（直接修改类方法）或者类装饰器</p><p>当然，这并不代表元类没什么用，想用到它的时候自然会用到的</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
