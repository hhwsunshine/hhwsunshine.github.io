<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="description" content=""><meta name="author" content="hhw"><meta name="keywords" content=""><title>Numpy使用 ~ hhw博客</title><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.10.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.8.9/css/mdb.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css"><link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><meta name="generator" content="Hexo 4.2.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>hhwsunshine's blog</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/">首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/">归档</a></li><li class="nav-item"><a class="nav-link" href="/tags/">标签</a></li><li class="nav-item"><a class="nav-link" href="/links/">友链</a></li><li class="nav-item"><a class="nav-link" href="/about/">关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2" id="background" style="background:url(/img/post_page.png) no-repeat center center;background-size:cover;background-attachment:scroll"><div class="full-bg-img"><div class="mask rgba-black-light flex-center"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><br><p class="mt-3"><i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp; 星期四, 二月 13日 2020, 9:26 上午</p><p>&nbsp;<i class="far fa-chart-bar"></i> <span class="post-count">4.7k 字 </span>&nbsp; &nbsp;<i class="far fa-clock"></i> <span class="post-count">23 分钟 </span>&nbsp; &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp; <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span> 次 </span>&nbsp;</p></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="py-5 z-depth-3" id="board"><div class="post-content mx-auto" id="post"><div class="markdown-body"><p>参考链接：</p><blockquote><p><a href="https://numpy.org/" target="_blank" rel="noopener">https://numpy.org/</a><br><a href="https://blog.csdn.net/cxmscb/article/details/54583415" target="_blank" rel="noopener">https://blog.csdn.net/cxmscb/article/details/54583415</a></p></blockquote><h2 id="NumPy数组对象"><a href="#NumPy数组对象" class="headerlink" title="NumPy数组对象"></a>NumPy数组对象</h2><ul><li><p>NumPy中的ndarray是一个多维数组对象，该对象由两部分组成</p><ul><li>实际的数据</li><li>描述这些数据的元数据</li></ul></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code class="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.arange(15).reshape(3, 5)
&gt;&gt;&gt; a
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
&gt;&gt;&gt; a.shape
(3, 5)
&gt;&gt;&gt; a.ndim  # 数组轴的个数，在python的世界中，轴的个数被称作秩
2
&gt;&gt;&gt; a.dtype.name
&#39;int64&#39;
&gt;&gt;&gt; a.itemsize  # 数组中每个元素的字节大小。
8
&gt;&gt;&gt; a.size
15
&gt;&gt;&gt; type(a)
&lt;type &#39;numpy.ndarray&#39;&gt;
&gt;&gt;&gt; b = np.array([6, 7, 8])
&gt;&gt;&gt; b
array([6, 7, 8])
&gt;&gt;&gt; type(b)
&lt;type &#39;numpy.ndarray&#39;&gt;</code></pre><h2 id="创建矩阵"><a href="#创建矩阵" class="headerlink" title="创建矩阵"></a>创建矩阵</h2><p>对于Python中的numpy模块，一般用其提供的ndarray对象。 创建一个ndarray对象很简单，只要将一个list作为参数即可。 例如:</p><pre><code class="python">&gt;&gt;&gt; import numpy as np
#创建一维的narray对象
&gt;&gt;&gt; a = np.array([2,3,4])
&gt;&gt;&gt; a
array([2, 3, 4])
&gt;&gt;&gt; a.dtype
dtype(&#39;int64&#39;)
# 浮点类型
&gt;&gt;&gt; b = np.array([1.2, 3.5, 5.1])
&gt;&gt;&gt; b.dtype
dtype(&#39;float64&#39;)
#创建二维的narray对象
&gt;&gt;&gt;a2 = np.array([[1,2,3,4,5],[6,7,8,9,10]])
&gt;&gt;&gt; b = np.array([(1.5,2,3), (4,5,6)])  # 使用的是元组
&gt;&gt;&gt; b
array([[ 1.5,  2. ,  3. ],
       [ 4. ,  5. ,  6. ]])
# The type of the array can also be explicitly specified at creation time:
&gt;&gt;&gt; c = np.array( [ [1,2], [3,4] ], dtype=complex )
&gt;&gt;&gt; c
array([[ 1.+0.j,  2.+0.j],
       [ 3.+0.j,  4.+0.j]])</code></pre><h2 id="矩阵行数列数"><a href="#矩阵行数列数" class="headerlink" title="矩阵行数列数"></a>矩阵行数列数</h2><pre><code class="python">import numpy as np
a = np.array([[1,2,3,4,5],[6,7,8,9,10]])
print(a.shape) #结果返回一个tuple元组 (2, 5) 2行，5列
print(a.shape[0]) #获得行数，返回 2
print(a.shape[1]) #获得列数，返回 5</code></pre><h2 id="矩阵按行列选取"><a href="#矩阵按行列选取" class="headerlink" title="矩阵按行列选取"></a>矩阵按行列选取</h2><p>矩阵的截取和list相同，可以通过[]（方括号）来截取</p><pre><code class="python">import numpy as np
a = np.array([[1,2,3,4,5],[6,7,8,9,10]])
print(a[0:1]) #截取第一行,返回 [[1 2 3 4 5]]
print(a[1,2:5]) #截取第二行，第三、四、五列，返回 [8 9 10]
print(a[1,:]) #截取第二行,返回 [ 6  7  8  9 10]</code></pre><h2 id="矩阵按条件截取"><a href="#矩阵按条件截取" class="headerlink" title="矩阵按条件截取"></a>矩阵按条件截取</h2><pre><code class="python">import numpy as np
a = np.array([[1,2,3,4,5],[6,7,8,9,10]])
b = a[a&gt;6] # 截取矩阵a中大于6的元素，返回的是一维数组
print(b) # 返回 [ 7  8  9 10]
# 其实布尔语句首先生成一个布尔矩阵，将布尔矩阵传入[]（方括号）实现截取
print(a&gt;6) 
# 返回
[[False False False False False]
 [False  True  True  True  True]]</code></pre><p>按条件截取应用较多的是对矩阵中满足一定条件的元素变成特定的值。 例如将矩阵中大于6的元素变成0。</p><pre><code class="python">import numpy as np
a = np.array([[1,2,3,4,5],[6,7,8,9,10]])
print(a)
#开始矩阵为
[[ 1  2  3  4  5]
 [ 6  7  8  9 10]]

a[a&gt;6] = 0
print(a)
#大于6清零后矩阵为
[[1 2 3 4 5]
 [6 0 0 0 0]]</code></pre><h2 id="Stacking-together-different-arrays"><a href="#Stacking-together-different-arrays" class="headerlink" title="Stacking together different arrays"></a>Stacking together different arrays</h2><p>矩阵的合并可以通过numpy中的hstack方法和vstack方法实现:</p><pre><code class="python">&gt;&gt;&gt; a = np.floor(10*np.random.random((2,2)))
&gt;&gt;&gt; a
array([[ 8.,  8.],
       [ 0.,  0.]])
&gt;&gt;&gt; b = np.floor(10*np.random.random((2,2)))
&gt;&gt;&gt; b
array([[ 1.,  8.],
       [ 0.,  4.]])
&gt;&gt;&gt; np.vstack((a,b))
array([[ 8.,  8.],
       [ 0.,  0.],
       [ 1.,  8.],
       [ 0.,  4.]])
&gt;&gt;&gt; np.hstack((a,b))
array([[ 8.,  8.,  1.,  8.],
       [ 0.,  0.,  0.,  4.]])</code></pre><ul><li>矩阵的合并也可以通过concatenatef方法。</li><li>np.concatenate( (a1,a2), axis=0 ) 等价于 np.vstack( (a1,a2) )</li><li>np.concatenate( (a1,a2), axis=1 ) 等价于 np.hstack( (a1,a2) )</li></ul><h2 id="通过函数创建矩阵"><a href="#通过函数创建矩阵" class="headerlink" title="通过函数创建矩阵"></a>通过函数创建矩阵</h2><p><strong>arange</strong></p><pre><code class="python">import numpy as np
a = np.arange(10) # 默认从0开始到10（不包括10），步长为1
print(a) # 返回 [0 1 2 3 4 5 6 7 8 9]
a1 = np.arange(5,10) # 从5开始到10（不包括10），步长为1
print(a1) # 返回 [5 6 7 8 9]
a2 = np.arange(5,20,2) # 从5开始到20（不包括20），步长为2
print(a2) # 返回 [ 5  7  9 11 13 15 17 19]</code></pre><p><strong>linspace/ logspace</strong></p><pre><code class="python">import numpy as np
# 类似于matlab
a = np.linspace(0,10,7) # 生成首位是0，末位是10，含7个数的等差数列
print(a) 
# 结果 
[  0.           1.66666667   3.33333333   5.         6.66666667  8.33333333  10.    ]

&gt;&gt;&gt; a = np.ones(3, dtype=np.int32)
&gt;&gt;&gt; b = np.linspace(0,pi,3)
&gt;&gt;&gt; b.dtype.name
&#39;float64&#39;
&gt;&gt;&gt; c = a+b
&gt;&gt;&gt; c
array([ 1.        ,  2.57079633,  4.14159265])
&gt;&gt;&gt; c.dtype.name
&#39;float64&#39;
&gt;&gt;&gt; d = np.exp(c*1j)
&gt;&gt;&gt; d
array([ 0.54030231+0.84147098j, -0.84147098+0.54030231j,
       -0.54030231-0.84147098j])
&gt;&gt;&gt; d.dtype.name
&#39;complex128&#39;</code></pre><p><strong>ones、zeros、eye、empty</strong><br>ones创建全1矩阵 ，zeros创建全0矩阵 ，eye创建单位矩阵 ，empty创建空矩阵（实际有值）</p><pre><code class="python">import numpy as np

a_ones = np.ones((3,4)) # 创建3*4的全1矩阵
print(a_ones)
# 结果
[[ 1.  1.  1.  1.]
 [ 1.  1.  1.  1.]
 [ 1.  1.  1.  1.]]

&gt;&gt;&gt; np.ones((2,3,4), dtype=np.int16 )   # dtype can also be specified
array([[[ 1, 1, 1, 1],
        [ 1, 1, 1, 1],
        [ 1, 1, 1, 1]],
       [[ 1, 1, 1, 1],
        [ 1, 1, 1, 1],
        [ 1, 1, 1, 1]]], dtype=int16)

a_zeros = np.zeros((3,4)) # 创建3*4的全0矩阵
print(a_zeros)
# 结果
[[ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]]

a_eye = np.eye(3) # 创建3阶单位矩阵
print(a_eye)
# 结果
[[ 1.  0.  0.]
 [ 0.  1.  0.]
 [ 0.  0.  1.]]

a_empty = np.empty((3,4)) # 创建3*4的空矩阵 
print(a_empty)
# 结果
[[  1.78006111e-306  -3.13259416e-294   4.71524461e-309   1.94927842e+289]
 [  2.10230387e-309   5.42870216e+294   6.73606381e-310   3.82265219e-297]
 [  6.24242356e-309   1.07034394e-296   2.12687797e+183   6.88703165e-315]]
# 有些矩阵太大，如果不想省略中间部分，通过set_printoptions来强制NumPy打印所有数据。
&gt;&gt;&gt; np.set_printoptions(threshold=&#39;nan&#39;)</code></pre><p><strong>fromstring</strong><br>fromstring()方法可以将字符串转化成ndarray对象，需要将字符串数字化时这个方法比较有用，可以获得字符串的ascii码序列。</p><pre><code class="python">import numpy as np

a = &quot;abcdef&quot;
b = np.fromstring(a,dtype=np.int8) # 因为一个字符为8位，所以指定dtype为np.int8
print(b) # 返回 [ 97  98  99 100 101 102] </code></pre><p><strong>random</strong></p><pre><code class="python">&gt;&gt;&gt; a = np.random.random((2,3)) # 产生2行,3列的随机矩阵 
&gt;&gt;&gt; a
array([[ 0.18626021,  0.34556073,  0.39676747],
       [ 0.53881673,  0.41919451,  0.6852195 ]])</code></pre><p><strong>fromfunction</strong><br>fromfunction()方法可以根据矩阵的行号列号生成矩阵的元素。 例如创建一个矩阵，矩阵中的每个元素都为行号和列号的和。</p><pre><code class="python">import numpy as np

def func(i,j): 
    return i+j

a = np.fromfunction(func,(5,6)) 
# 第一个参数为指定函数，第二个参数为列表list或元组tuple,说明矩阵的大小
print(a)
# 返回
[[ 0.  1.  2.  3.  4.  5.]
 [ 1.  2.  3.  4.  5.  6.]
 [ 2.  3.  4.  5.  6.  7.]
 [ 3.  4.  5.  6.  7.  8.]
 [ 4.  5.  6.  7.  8.  9.]]
#注意这里行号的列号都是从0开始的</code></pre><h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><p><strong>常用矩阵运算符</strong><br>Numpy中的ndarray对象重载了许多运算符，使用这些运算符可以完成矩阵间对应元素的运算。</p><p>运算符说明+矩阵对应元素相加-矩阵对应元素相减*矩阵对应元素相乘/矩阵对应元素相除，如果都是整数则取商%矩阵对应元素相除后取余数**矩阵每个元素都取n次方，如**2：每个元素都取平方</p><pre><code class="python">import numpy as np
a1 = np.array([[4,5,6],[1,2,3]])
a2 = np.array([[6,5,4],[3,2,1]])

print(a1+a2) # 相加
# 结果
[[10 10 10]
 [ 4  4  4]]

print(a1/a2) # 整数相除取商
# 结果
[[0 1 1]
 [0 1 3]]

print(a1%a2) # 相除取余数
# 结果
[[4 0 2]
 [1 0 0]]</code></pre><p><strong>常用矩阵函数</strong></p><p>同样地，numpy中也定义了许多函数，使用这些函数可以将函数作用于矩阵中的每个元素。 表格中默认导入了numpy模块，即 import numpy as np 。a为ndarray对象。</p><p><strong>常用矩阵函数说明</strong>np.sin(a)对矩阵a中每个元素取正弦,sin(x)np.cos(a)对矩阵a中每个元素取余弦,cos(x)np.tan(a)对矩阵a中每个元素取正切,tan(x)np.arcsin(a)对矩阵a中每个元素取反正弦,arcsin(x)np.arccos(a)对矩阵a中每个元素取反余弦,arccos(x)np.arctan(a)对矩阵a中每个元素取反正切,arctan(x)np.exp(a)对矩阵a中每个元素取指数函数,exnp.sqrt(a)对矩阵a中每个元素开根号</p><ul><li>当矩阵中的元素不在函数定义域范围内，会产生RuntimeWarning，结果为nan(not a number)</li></ul><p><strong>矩阵乘法（点乘）</strong><br>矩阵乘法必须满足矩阵乘法的条件，即第一个矩阵的列数等于第二个矩阵的行数。 矩阵乘法的函数为 dot 。</p><pre><code class="python">import numpy as np

a1 = np.array([[1,2,3],[4,5,6]]) # a1为2*3矩阵
a2 = np.array([[1,2],[3,4],[5,6]]) # a2为3*2矩阵

print(a1.shape[1]==a2.shape[0]) # True, 满足矩阵乘法条件
print(a1.dot(a2)) 
# a1.dot(a2)相当于matlab中的a1*a2
# 而Python中的a1*a2相当于matlab中的a1.*a2
# 结果
[[22 28]
 [49 64]]</code></pre><p><strong>矩阵的转置 a.T</strong></p><pre><code class="python">import numpy as np
a = np.array([[1,2,3],[4,5,6]])
print(a.transpose())
# 结果
[[1 4]
 [2 5]
 [3 6]]</code></pre><p>矩阵的转置还有更简单的方法，就是a.T。</p><pre><code class="python">import numpy as np

a = np.array([[1,2,3],[4,5,6]])
print(a.T)
# 结果
[[1 4]
 [2 5]
 [3 6]]</code></pre><p><strong>矩阵的逆</strong></p><blockquote><p>设A是数域上的一个n阶方阵，若在相同数域上存在另一个n阶矩阵B，使得： AB=BA=E。 则我们称B是A的逆矩阵，而A则被称为可逆矩阵。</p></blockquote><p>求矩阵的逆需要先导入numpy.linalg，用linalg的inv函数来求逆。矩阵求逆的条件是矩阵应该是方阵。</p><pre><code class="python">import numpy as np
import numpy.linalg as lg

a = np.array([[1,2,3],[4,5,6],[7,8,9]])

print(lg.inv(a))
# 结果
[[ -4.50359963e+15   9.00719925e+15  -4.50359963e+15]
 [  9.00719925e+15  -1.80143985e+16   9.00719925e+15]
 [ -4.50359963e+15   9.00719925e+15  -4.50359963e+15]]

a = np.eye(3) # 3阶单位矩阵
print(lg.inv(a)) # 单位矩阵的逆为他本身
# 结果
[[ 1.  0.  0.]
 [ 0.  1.  0.]
 [ 0.  0.  1.]]</code></pre><h2 id="矩阵信息获取（如均值等）"><a href="#矩阵信息获取（如均值等）" class="headerlink" title="矩阵信息获取（如均值等）"></a>矩阵信息获取（如均值等）</h2><p><strong>最值</strong><br>获得矩阵中元素最大最小值的函数分别是max和min，可以获得整个矩阵、行或列的最大最小值。</p><pre><code class="python">import numpy as np

a = np.array([[1,2,3],[4,5,6]])
print(a.max()) #获取整个矩阵的最大值 结果： 6
print(a.min()) #结果：1

# 可以指定关键字参数axis来获得行最大（小）值或列最大（小）值
# axis=0 行方向最大（小）值，即获得每列的最大（小）值
# axis=1 列方向最大（小）值，即获得每行的最大（小）值
# 例如

print(a.max(axis=0))
# 结果为 [4 5 6]

print(a.max(axis=1))
# 结果为 [3 6]

# 要想获得最大最小值元素所在的位置，可以通过argmax函数来获得
print(a.argmax(axis=1))
# 结果为 [2 2]</code></pre><p><strong>平均值</strong></p><p>获得矩阵中元素的平均值可以通过函数mean()。同样地，可以获得整个矩阵、行或列的平均值。</p><pre><code class="python">import numpy as np

a = np.array([[1,2,3],[4,5,6]])
print(a.mean()) #结果为： 3.5

# 同样地，可以通过关键字axis参数指定沿哪个方向获取平均值
print(a.mean(axis=0)) # 结果 [ 2.5  3.5  4.5]
print(a.mean(axis=1)) # 结果 [ 2.  5.]</code></pre><p><strong>方差</strong></p><p>方差的函数为var(),方差函数var()相当于函数mean(abs(x - x.mean())**2),其中x为矩阵。</p><pre><code class="python">import numpy as np

a = np.array([[1,2,3],[4,5,6]])
print(a.var()) # 结果 2.91666666667

print(a.var(axis=0)) # 结果 [ 2.25  2.25  2.25]
print(a.var(axis=1)) # 结果 [ 0.66666667  0.66666667]</code></pre><p><strong>标准差</strong></p><p>标准差的函数为std()。 std()相当于sqrt(mean(abs(x - x.mean())**2))，或相当于sqrt(x.var())。</p><pre><code class="python">import numpy as np

a = np.array([[1,2,3],[4,5,6]])
print(a.std()) # 结果 1.70782512766

print(a.std(axis=0)) # 结果 [ 1.5  1.5  1.5]
print(a.std(axis=1)) # 结果 [ 0.81649658  0.81649658]</code></pre><p><strong>中值</strong></p><p>中值指的是将序列按大小顺序排列后，排在中间的那个值，如果有偶数个数，则是排在中间两个数的平均值。中值的函数是median()，调用方法为numpy.median(x,[axis])，axis可指定轴方向，默认axis=None，对所有数取中值。</p><pre><code class="python">import numpy as np
x = np.array([[1,2,3],[4,5,6]])

print(np.median(x))  # 对所有数取中值
# 结果
3.5

print(np.median(x,axis=0))  # 沿第一维方向取中值
# 结果
[ 2.5  3.5  4.5]

print(np.median(x,axis=1))  # 沿第二维方向取中值
# 结果
[ 2.  5.]</code></pre><p><strong>求和</strong><br>矩阵求和的函数是sum()，可以对行，列，或整个矩阵求和</p><pre><code class="python">import numpy as np

a = np.array([[1,2,3],[4,5,6]])

print(a.sum())           # 对整个矩阵求和
# 结果 21

print(a.sum(axis=0)) # 对行方向求和
# 结果 [5 7 9]

print(a.sum(axis=1)) # 对列方向求和
# 结果 [ 6 15]</code></pre><p><strong>累积和</strong><br>某位置累积和指的是该位置之前(包括该位置)所有元素的和。例如序列[1,2,3,4,5]，其累计和为[1,3,6,10,15]，即第一个元素为1，第二个元素为1+2=3，……，第五个元素为1+2+3+4+5=15。矩阵求累积和的函数是cumsum()，可以对行，列，或整个矩阵求累积和。</p><pre><code class="python">import numpy as np

a = np.array([[1,2,3],[4,5,6]])

print(a.cumsum())            # 对整个矩阵求累积和
# 结果 [ 1  3  6 10 15 21]

print(a.cumsum(axis=0))  # 对列方向求累积和
# 结果
[[1 2 3]
 [5 7 9]]

print(  a.cumsum(axis=1))  # 对行方向求累积和
# 结果
[[ 1  3  6]
 [ 4  9 15]]</code></pre><p><strong>极差</strong></p><pre><code class="python">&gt;&gt;&gt;import numpy as np
&gt;&gt;&gt;a = np.arange(10)
&gt;&gt;&gt;a.ptp()
# 结果是
9</code></pre><p><strong>百分位数</strong></p><pre><code class="python">numpy.percentile(a, q, axis)</code></pre><p><strong>序号参数及描述</strong>1.a 输入数组2.q 要计算的百分位数，在 0 ~ 100 之间3.axis 沿着它计算百分位数的轴</p><p><strong>加权平均值</strong></p><pre><code class="python">&gt;&gt;&gt; data = range(1,5)
&gt;&gt;&gt; data
[1, 2, 3, 4]
&gt;&gt;&gt; np.average(data)
2.5
&gt;&gt;&gt; np.average(range(1,11), weights=range(10,0,-1))
4.0
&gt;&gt;&gt; data = np.arange(6).reshape((3,2))
&gt;&gt;&gt; data
array([[0, 1],
       [2, 3],
       [4, 5]])
&gt;&gt;&gt; np.average(data, axis=1, weights=[1./4, 3./4])
array([ 0.75,  2.75,  4.75])
&gt;&gt;&gt; np.average(data, weights=[1./4, 3./4])
Traceback (most recent call last):
...
TypeError: Axis must be specified when shapes of a and weights differ.</code></pre><h2 id="Shape-Manipulation"><a href="#Shape-Manipulation" class="headerlink" title="Shape Manipulation"></a>Shape Manipulation</h2><p><strong>Changing the shape of an array</strong></p><pre><code class="python">&gt;&gt;&gt; a = np.floor(10*np.random.random((3,4)))
&gt;&gt;&gt; a
array([[ 2.,  8.,  0.,  6.],
       [ 4.,  5.,  1.,  1.],
       [ 8.,  9.,  3.,  6.]])
&gt;&gt;&gt; a.shape
(3, 4)</code></pre><p>数组的形状可以用以下方式改变。Note that the following three commands all return a modified array, but do not change the original array:</p><pre><code class="python">&gt;&gt;&gt; a.ravel()  # returns the array, flattened
array([ 2.,  8.,  0.,  6.,  4.,  5.,  1.,  1.,  8.,  9.,  3.,  6.])
&gt;&gt;&gt; a.reshape(6,2)  # returns the array with a modified shape
array([[ 2.,  8.],
       [ 0.,  6.],
       [ 4.,  5.],
       [ 1.,  1.],
       [ 8.,  9.],
       [ 3.,  6.]])
&gt;&gt;&gt; a.T  # returns the array, transposed
array([[ 2.,  4.,  8.],
       [ 8.,  5.,  9.],
       [ 0.,  1.,  3.],
       [ 6.,  1.,  6.]])
&gt;&gt;&gt; a.T.shape
(4, 3)
&gt;&gt;&gt; a.shape
(3, 4)</code></pre><p>The reshape function returns its argument with a modified shape, whereas thendarray.resize method modifies the array itself:</p><pre><code class="python">&gt;&gt;&gt; a
array([[ 2.,  8.,  0.,  6.],
       [ 4.,  5.,  1.,  1.],
       [ 8.,  9.,  3.,  6.]])
&gt;&gt;&gt; a.resize((2,6))
&gt;&gt;&gt; a
array([[ 2.,  8.,  0.,  6.,  4.,  5.],
       [ 1.,  1.,  8.,  9.,  3.,  6.]])</code></pre><p>If a dimension is given as -1 in a reshaping operation, the other dimensions are automatically calculated:</p><pre><code class="python">&gt;&gt;&gt; a.reshape(3,-1)
array([[ 2.,  8.,  0.,  6.],
       [ 4.,  5.,  1.,  1.],
       [ 8.,  9.,  3.,  6.]])</code></pre><p><strong>Splitting one array into several smaller ones</strong><br>Using hsplit, you can split an array along its horizontal axis, either by specifying the number of equally shaped arrays to return, or by specifying the columns after which the division should occur:</p><pre><code class="python">&gt;&gt;&gt; a = np.floor(10*np.random.random((2,12)))
&gt;&gt;&gt; a
array([[ 9.,  5.,  6.,  3.,  6.,  8.,  0.,  7.,  9.,  7.,  2.,  7.],
       [ 1.,  4.,  9.,  2.,  2.,  1.,  0.,  6.,  2.,  2.,  4.,  0.]])
&gt;&gt;&gt; np.hsplit(a,3)   # Split a into 3
[array([[ 9.,  5.,  6.,  3.],
       [ 1.,  4.,  9.,  2.]]), array([[ 6.,  8.,  0.,  7.],
       [ 2.,  1.,  0.,  6.]]), array([[ 9.,  7.,  2.,  7.],
       [ 2.,  2.,  4.,  0.]])]</code></pre><p><strong>Copies and Views</strong></p><p>When operating and manipulating arrays, their data is sometimes copied into a new array and sometimes not. This is often a source of confusion for beginners. There are three cases:</p><p><strong>No Copy At All</strong></p><p>a = b,改变b就相当于改变a,或者相反。</p><pre><code class="python">&gt;&gt;&gt; a = np.arange(12)
&gt;&gt;&gt; b = a            # no new object is created
&gt;&gt;&gt; b is a           # a and b are two names for the same ndarray object
True
&gt;&gt;&gt; b.shape = 3,4    # changes the shape of a
&gt;&gt;&gt; a.shape
(3, 4)</code></pre><p><strong>View or Shallow Copy</strong></p><p>Different array objects can share the same data. The view method creates a new array object that looks at the same data.</p><pre><code class="python">&gt;&gt;&gt; c = a.view()
&gt;&gt;&gt; c is a
False
&gt;&gt;&gt; c.base is a                        # c is a view of the data owned by a
True
&gt;&gt;&gt; c.flags.owndata
False
&gt;&gt;&gt;
&gt;&gt;&gt; c.shape = 2,6                      # a&#39;s shape doesn&#39;t change
&gt;&gt;&gt; a.shape
(3, 4)
&gt;&gt;&gt; c[0,4] = 1234                      # a&#39;s data changes
&gt;&gt;&gt; a
array([[   0,    1,    2,    3],
       [1234,    5,    6,    7],
       [   8,    9,   10,   11]])</code></pre><p>Slicing an array returns a view of it:</p><pre><code class="python">&gt;&gt;&gt; s = a[:,1:3]  # spaces added for clarity; could also be written &quot;s = a[:,1:3]&quot;
&gt;&gt;&gt; s[:] = 10    # s[:] is a view of s. Note the difference between s=10 and s[:]=10
&gt;&gt;&gt; a
array([[   0,   10,   10,    3],
       [1234,   10,   10,    7],
       [   8,   10,   10,   11]])</code></pre><p><strong>Deep Copy</strong></p><p>The copy method makes a complete copy of the array and its data.</p><pre><code class="python">&gt;&gt;&gt; d = a.copy()                          # a new array object with new data is created
&gt;&gt;&gt; d is a
False
&gt;&gt;&gt; d.base is a                           # d doesn&#39;t share anything with a
False
&gt;&gt;&gt; d[0,0] = 9999
&gt;&gt;&gt; a
array([[   0,   10,   10,    3],
       [1234,   10,   10,    7],
       [   8,   10,   10,   11]])</code></pre><p>numpy关于copy有三种情况，<strong>完全不复制、视图（view）</strong>或者叫浅复制（shadow copy）和<strong>深复制</strong>（deep copy）。而b = a[:]就属于第二种，即视图，这本质上是一种切片操作（slicing），所有的切片操作返回的都是视图。具体来说，b = a[:]会创建一个新的对象b（所以说 id 和a不一样），但是b的数据完全来自于a，和a保持完全一致，换句话说，<strong>b的数据完全由a保管</strong>，他们两个的数据变化是一致的，可以看下面的示例:</p><pre><code class="python">a = np.arange(4)  # array([0, 1, 2, 3])
b = a[:]  # array([0, 1, 2, 3])

b.flags.owndata  # 返回 False，b 并不保管数据
a.flags.owndata  # 返回 True，数据由 a 保管

# 改变 a 同时也影响到 b
a[-1] = 10  # array([0, 1, 2, 10])
b  #  array([0, 1, 2, 10])

# 改变 b 同时也影响到 a
b[0] = 10  # array([10, 1, 2, 10])
a  # array([10, 1, 2, 10])</code></pre><p>b = a 和 b = a[:] 的差别就在于后者会创建新的对象，前者不会。两种方式都会导致a和b的数据相互影响。要想不让a的改动影响到b，可以使用深复制：unique_b = a.copy()</p><p><strong>曼德勃罗</strong></p><pre><code class="python">import numpy as np
import matplotlib.pyplot as plt
def mandelbrot( h,w, maxit=20 ):
    &quot;&quot;&quot;Returns an image of the Mandelbrot fractal of size (h,w).&quot;&quot;&quot;
    y,x = np.ogrid[ -1.4:1.4:h*1j, -2:0.8:w*1j ]
    c = x+y*1j
    z = c
    divtime = maxit + np.zeros(z.shape, dtype=int)

    for i in range(maxit):
        z = z**2 + c
        diverge = z*np.conj(z) &gt; 2**2            # who is diverging
        div_now = diverge &amp; (divtime==maxit)  # who is diverging now
        divtime[div_now] = i                  # note when
        z[diverge] = 2                        # avoid diverging too much

    return divtime
plt.imshow(mandelbrot(400,400))
plt.show()</code></pre><p><img src="/img/content/numpy/1.png" srcset="/img/loading.gif" alt=""></p><hr></div><br><div><p></p><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container"><div id="toc"><p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-md"><div class="container comments mx-auto" id="comments"><br><br><div id="vcomments" style="width:90%;margin:0 auto"></div><script defer src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script defer src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var notify=!1,verify=!1,oldLoad=window.onload;window.onload=function(){new Valine({el:"#vcomments",notify:notify,verify:verify,app_id:"Q7daliAwM6QkVFJwlwVmU12t-gzGzoHsz",app_key:"OWkCjqwgMVA17MQI9vOGwkru",placeholder:"说点什么",avatar:"retro",meta:["nick","mail","link"],pageSize:"10"}),oldLoad&&oldLoad()}</script><noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments powered by Valine.</a></noscript></div></div></main><a class="z-depth-1" id="scroll-top-button" href="#" role="button"><i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><b>Fluid</b></a><br>&nbsp;<span id="busuanzi_container_site_pv"></span>总访问量 <span id="busuanzi_value_site_pv"></span> 次&nbsp; &nbsp;<span id="busuanzi_container_site_uv"></span>总访客数 <span id="busuanzi_value_site_uv"></span> 人&nbsp;<br></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/popper.js/1.15.0/umd/popper.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script><script src="https://cdn.staticfile.org/mdbootstrap/4.8.9/js/mdb.min.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.staticfile.org/tocbot/4.8.0/tocbot.min.js"></script><script src="/js/post.js"></script><script src="https://cdn.staticfile.org/smoothscroll/1.4.10/SmoothScroll.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.staticfile.org/prettify/r298/prettify.min.js"></script><script>$(document).ready(function(){$("pre").addClass("prettyprint  linenums"),prettyPrint()})</script><script src="https://cdn.staticfile.org/typed.js/2.0.10/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","Numpy使用&nbsp;"],cursorChar:"_",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.0/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){getSearchFile(path),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><script>$("#post img:not(.no-zoom img, img[no-zoom])").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>